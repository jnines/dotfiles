From 708c1003d7454dd8621207a61feeda0cb9c03c03 Mon Sep 17 00:00:00 2001
From: jnines <jason.mullenberg@gmail.com>
Date: Thu, 26 Feb 2026 18:20:47 -0600
Subject: [PATCH] Compact tasks

---
 applets/CMakeLists.txt                        |   1 +
 applets/taskmanager_compact/CMakeLists.txt    |  61 ++
 applets/taskmanager_compact/Messages.sh       |   2 +
 applets/taskmanager_compact/backend.cpp       | 521 ++++++++++++
 applets/taskmanager_compact/backend.h         |  81 ++
 applets/taskmanager_compact/main.xml          | 160 ++++
 applets/taskmanager_compact/metadata.json     | 166 ++++
 .../taskmanager_compact/qml/AudioStream.qml   | 182 ++++
 applets/taskmanager_compact/qml/Badge.qml     |  59 ++
 .../qml/ConfigAppearance.qml                  | 201 +++++
 .../qml/ConfigBehavior.qml                    | 306 +++++++
 .../taskmanager_compact/qml/ContextMenu.qml   | 798 ++++++++++++++++++
 .../taskmanager_compact/qml/GroupDialog.qml   | 201 +++++
 .../qml/GroupExpanderOverlay.qml              |  84 ++
 .../taskmanager_compact/qml/MouseHandler.qml  | 202 +++++
 .../qml/PipeWireThumbnail.qml                 |  23 +
 .../qml/PlayerController.qml                  |  92 ++
 .../taskmanager_compact/qml/PulseAudio.qml    | 121 +++
 .../qml/ScrollableTextWrapper.qml             |  65 ++
 applets/taskmanager_compact/qml/Task.qml      | 693 +++++++++++++++
 .../qml/TaskBadgeOverlay.qml                  |  86 ++
 applets/taskmanager_compact/qml/TaskList.qml  |  62 ++
 .../qml/TaskProgressOverlay.qml               |  49 ++
 .../qml/ToolTipDelegate.qml                   | 174 ++++
 .../qml/ToolTipInstance.qml                   | 543 ++++++++++++
 .../qml/ToolTipWindowMouseArea.qml            |  42 +
 .../qml/code/LayoutMetrics.js                 | 164 ++++
 .../taskmanager_compact/qml/code/TaskTools.js | 259 ++++++
 applets/taskmanager_compact/qml/config.qml    |  22 +
 applets/taskmanager_compact/qml/main.qml      | 572 +++++++++++++
 .../smartlauncherbackend.cpp                  | 251 ++++++
 .../smartlauncherbackend.h                    | 120 +++
 .../taskmanager_compact/smartlauncheritem.cpp | 225 +++++
 .../taskmanager_compact/smartlauncheritem.h   |  82 ++
 34 files changed, 6670 insertions(+)
 create mode 100644 applets/taskmanager_compact/CMakeLists.txt
 create mode 100644 applets/taskmanager_compact/Messages.sh
 create mode 100644 applets/taskmanager_compact/backend.cpp
 create mode 100644 applets/taskmanager_compact/backend.h
 create mode 100644 applets/taskmanager_compact/main.xml
 create mode 100644 applets/taskmanager_compact/metadata.json
 create mode 100644 applets/taskmanager_compact/qml/AudioStream.qml
 create mode 100644 applets/taskmanager_compact/qml/Badge.qml
 create mode 100644 applets/taskmanager_compact/qml/ConfigAppearance.qml
 create mode 100644 applets/taskmanager_compact/qml/ConfigBehavior.qml
 create mode 100644 applets/taskmanager_compact/qml/ContextMenu.qml
 create mode 100644 applets/taskmanager_compact/qml/GroupDialog.qml
 create mode 100644 applets/taskmanager_compact/qml/GroupExpanderOverlay.qml
 create mode 100644 applets/taskmanager_compact/qml/MouseHandler.qml
 create mode 100644 applets/taskmanager_compact/qml/PipeWireThumbnail.qml
 create mode 100644 applets/taskmanager_compact/qml/PlayerController.qml
 create mode 100644 applets/taskmanager_compact/qml/PulseAudio.qml
 create mode 100644 applets/taskmanager_compact/qml/ScrollableTextWrapper.qml
 create mode 100644 applets/taskmanager_compact/qml/Task.qml
 create mode 100644 applets/taskmanager_compact/qml/TaskBadgeOverlay.qml
 create mode 100644 applets/taskmanager_compact/qml/TaskList.qml
 create mode 100644 applets/taskmanager_compact/qml/TaskProgressOverlay.qml
 create mode 100644 applets/taskmanager_compact/qml/ToolTipDelegate.qml
 create mode 100644 applets/taskmanager_compact/qml/ToolTipInstance.qml
 create mode 100644 applets/taskmanager_compact/qml/ToolTipWindowMouseArea.qml
 create mode 100644 applets/taskmanager_compact/qml/code/LayoutMetrics.js
 create mode 100644 applets/taskmanager_compact/qml/code/TaskTools.js
 create mode 100644 applets/taskmanager_compact/qml/config.qml
 create mode 100644 applets/taskmanager_compact/qml/main.qml
 create mode 100644 applets/taskmanager_compact/smartlauncherbackend.cpp
 create mode 100644 applets/taskmanager_compact/smartlauncherbackend.h
 create mode 100644 applets/taskmanager_compact/smartlauncheritem.cpp
 create mode 100644 applets/taskmanager_compact/smartlauncheritem.h

diff --git a/applets/CMakeLists.txt b/applets/CMakeLists.txt
index 77263e5a63..d9f573a25c 100644
--- a/applets/CMakeLists.txt
+++ b/applets/CMakeLists.txt
@@ -18,3 +18,4 @@ add_subdirectory(minimizeall)
 add_subdirectory(showdesktop)
 add_subdirectory(kimpanel)
 add_subdirectory(keyboardlayout)
+add_subdirectory(taskmanager_compact)
diff --git a/applets/taskmanager_compact/CMakeLists.txt b/applets/taskmanager_compact/CMakeLists.txt
new file mode 100644
index 0000000000..057d29f1a5
--- /dev/null
+++ b/applets/taskmanager_compact/CMakeLists.txt
@@ -0,0 +1,61 @@
+add_definitions(-DTRANSLATION_DOMAIN=\"plasma_applet_org.kde.plasma.taskmanager.compact\")
+
+plasma_add_applet(org.kde.plasma.taskmanager.compact
+    QML_SOURCES
+        qml/AudioStream.qml
+        qml/Badge.qml
+        qml/ConfigAppearance.qml
+        qml/ConfigBehavior.qml
+        qml/config.qml
+        qml/ContextMenu.qml
+        qml/GroupDialog.qml
+        qml/GroupExpanderOverlay.qml
+        qml/main.qml
+        qml/MouseHandler.qml
+        qml/PipeWireThumbnail.qml
+        qml/PlayerController.qml
+        qml/PulseAudio.qml
+        qml/ScrollableTextWrapper.qml
+        qml/TaskBadgeOverlay.qml
+        qml/TaskList.qml
+        qml/TaskProgressOverlay.qml
+        qml/Task.qml
+        qml/ToolTipDelegate.qml
+        qml/ToolTipInstance.qml
+        qml/ToolTipWindowMouseArea.qml
+        qml/code/LayoutMetrics.js
+        qml/code/TaskTools.js
+    CPP_SOURCES
+        backend.cpp
+        smartlauncherbackend.cpp
+        smartlauncheritem.cpp
+    RESOURCES
+        main.xml
+    GENERATE_APPLET_CLASS
+)
+
+kconfig_add_kcfg_files(org.kde.plasma.taskmanager.compact ${CMAKE_SOURCE_DIR}/kcms/recentFiles/kactivitymanagerd_plugins_settings.kcfgc)
+
+ecm_qt_declare_logging_category(org.kde.plasma.taskmanager.compact
+    HEADER log_settings.h
+    IDENTIFIER TASKMANAGER_DEBUG
+    CATEGORY_NAME org.kde.plasma.taskmanager.compact)
+
+# FIXME Cleanup no longer used libs.
+target_link_libraries(org.kde.plasma.taskmanager.compact PRIVATE
+                      Qt::Core
+                      Qt::Qml
+                      Qt::Quick
+                      Plasma::Activities
+                      Plasma::ActivitiesStats
+                      KF6::ConfigGui
+                      KF6::I18n
+                      KF6::KIOCore
+                      KF6::KIOGui
+                      KF6::KIOFileWidgets # KFilePlacesModel
+                      KF6::Notifications # KNotificationJobUiDelegate
+                      Plasma::Plasma
+                      KSysGuard::ProcessCore
+                      KF6::Service
+                      KF6::WindowSystem
+                      PW::LibNotificationManager)
diff --git a/applets/taskmanager_compact/Messages.sh b/applets/taskmanager_compact/Messages.sh
new file mode 100644
index 0000000000..c86f8d757e
--- /dev/null
+++ b/applets/taskmanager_compact/Messages.sh
@@ -0,0 +1,2 @@
+#! /usr/bin/env bash
+$XGETTEXT `find . -name \*.js -o -name \*.qml -o -name \*.cpp` -o $podir/plasma_applet_org.kde.plasma.taskmanager.pot
diff --git a/applets/taskmanager_compact/backend.cpp b/applets/taskmanager_compact/backend.cpp
new file mode 100644
index 0000000000..6516a7ed4b
--- /dev/null
+++ b/applets/taskmanager_compact/backend.cpp
@@ -0,0 +1,521 @@
+/*
+    SPDX-FileCopyrightText: 2012-2016 Eike Hein <hein@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+#include "backend.h"
+
+#include "log_settings.h"
+#include <KConfigGroup>
+#include <KDesktopFile>
+#include <KFileItem>
+#include <KFilePlacesModel>
+#include <KLocalizedString>
+#include <KNotificationJobUiDelegate>
+#include <KProtocolInfo>
+#include <KService>
+#include <KServiceAction>
+#include <KWindowEffects>
+#include <KWindowSystem>
+
+#include <KApplicationTrader>
+#include <KIO/ApplicationLauncherJob>
+
+#include <QAction>
+#include <QActionGroup>
+#include <QApplication>
+#include <QJsonArray>
+#include <QMenu>
+#include <QQuickItem>
+#include <QQuickWindow>
+#include <QStandardPaths>
+#include <QTimer>
+#include <QVersionNumber>
+
+#include <PlasmaActivities/Consumer>
+#include <PlasmaActivities/Stats/Cleaning>
+#include <PlasmaActivities/Stats/ResultSet>
+#include <PlasmaActivities/Stats/Terms>
+
+#include <processcore/process.h>
+#include <processcore/processes.h>
+
+namespace KAStats = KActivities::Stats;
+
+using namespace KAStats;
+using namespace KAStats::Terms;
+
+static constexpr int NoApplications = 2; // kactivitymanager StatsPlugin WhatToRemember.
+
+Backend::Backend(QObject *parent)
+    : QObject(parent)
+    , m_actionGroup(new QActionGroup(this))
+    , m_activityManagerPluginsSettingsWatcher(KConfigWatcher::create(m_activityManagerPluginsSettings.sharedConfig()))
+{
+    connect(m_activityManagerPluginsSettingsWatcher.get(),
+            &KConfigWatcher::configChanged,
+            this,
+            [this](const KConfigGroup &group, const QByteArrayList &names) {
+                if (group.name() == QLatin1String("Plugin-org.kde.ActivityManager.Resources.Scoring")
+                    && names.contains(QByteArrayLiteral("what-to-remember"))) {
+                    m_activityManagerPluginsSettings.load();
+                }
+            });
+}
+
+Backend::~Backend()
+{
+}
+
+QUrl Backend::tryDecodeApplicationsUrl(const QUrl &launcherUrl)
+{
+    if (launcherUrl.isValid() && launcherUrl.scheme() == QLatin1String("applications")) {
+        const KService::Ptr service = KService::serviceByMenuId(launcherUrl.path());
+
+        if (service) {
+            return QUrl::fromLocalFile(service->entryPath());
+        }
+    }
+
+    return launcherUrl;
+}
+
+QStringList Backend::applicationCategories(const QUrl &launcherUrl)
+{
+    const QUrl desktopEntryUrl = tryDecodeApplicationsUrl(launcherUrl);
+
+    if (!desktopEntryUrl.isValid() || !desktopEntryUrl.isLocalFile() || !KDesktopFile::isDesktopFile(desktopEntryUrl.toLocalFile())) {
+        return QStringList();
+    }
+
+    KDesktopFile desktopFile(desktopEntryUrl.toLocalFile());
+
+    // Since we can't have dynamic jump list actions, at least add the user's "Places" for file managers.
+    return desktopFile.desktopGroup().readXdgListEntry(QStringLiteral("Categories"));
+}
+
+QVariantList Backend::jumpListActions(const QUrl &launcherUrl, QObject *parent)
+{
+    QVariantList actions;
+
+    if (!parent) {
+        return actions;
+    }
+
+    QUrl desktopEntryUrl = tryDecodeApplicationsUrl(launcherUrl);
+
+    if (!desktopEntryUrl.isValid() || !desktopEntryUrl.isLocalFile() || !KDesktopFile::isDesktopFile(desktopEntryUrl.toLocalFile())) {
+        return actions;
+    }
+
+    const KService::Ptr service = KService::serviceByDesktopPath(desktopEntryUrl.toLocalFile());
+    if (!service) {
+        return actions;
+    }
+
+    if (service->storageId() == QLatin1String("systemsettings.desktop")) {
+        actions = systemSettingsActions(parent);
+        if (!actions.isEmpty()) {
+            return actions;
+        }
+    }
+
+    const auto jumpListActions = service->actions();
+
+    for (const KServiceAction &serviceAction : jumpListActions) {
+        if (serviceAction.noDisplay()) {
+            continue;
+        }
+
+        QAction *action = new QAction(parent);
+        action->setText(serviceAction.text());
+        action->setIcon(QIcon::fromTheme(serviceAction.icon()));
+        if (serviceAction.isSeparator()) {
+            action->setSeparator(true);
+        }
+
+        connect(action, &QAction::triggered, this, [serviceAction]() {
+            auto *job = new KIO::ApplicationLauncherJob(serviceAction);
+            auto *delegate = new KNotificationJobUiDelegate;
+            delegate->setAutoErrorHandlingEnabled(true);
+            job->setUiDelegate(delegate);
+            job->start();
+        });
+
+        actions << QVariant::fromValue<QAction *>(action);
+    }
+
+    return actions;
+}
+
+QVariantList Backend::systemSettingsActions(QObject *parent) const
+{
+    QVariantList actions;
+
+    if (m_activityManagerPluginsSettings.whatToRemember() == NoApplications) {
+        return actions;
+    }
+
+    auto query = AllResources | Agent(QStringLiteral("org.kde.systemsettings")) | HighScoredFirst | Limit(5);
+
+    ResultSet results(query);
+
+    QStringList ids;
+    for (const ResultSet::Result &result : results) {
+        ids << QUrl(result.resource()).path();
+    }
+
+    if (ids.count() < 5) {
+        // We'll load the default set of settings from its jump list actions.
+        return actions;
+    }
+
+    for (const QString &id : std::as_const(ids)) {
+        KService::Ptr service = KService::serviceByStorageId(id);
+        if (!service || !service->isValid()) {
+            continue;
+        }
+
+        QAction *action = new QAction(parent);
+        action->setText(service->name());
+        action->setIcon(QIcon::fromTheme(service->icon()));
+
+        connect(action, &QAction::triggered, this, [service]() {
+            auto *job = new KIO::ApplicationLauncherJob(service);
+            auto *delegate = new KNotificationJobUiDelegate;
+            delegate->setAutoErrorHandlingEnabled(true);
+            job->setUiDelegate(delegate);
+            job->start();
+        });
+
+        actions << QVariant::fromValue<QAction *>(action);
+    }
+    return actions;
+}
+
+QVariantList Backend::placesActions(const QUrl &launcherUrl, bool showAllPlaces, QObject *parent)
+{
+    if (!parent) {
+        return QVariantList();
+    }
+
+    QUrl desktopEntryUrl = tryDecodeApplicationsUrl(launcherUrl);
+
+    if (!desktopEntryUrl.isValid() || !desktopEntryUrl.isLocalFile() || !KDesktopFile::isDesktopFile(desktopEntryUrl.toLocalFile())) {
+        return QVariantList();
+    }
+
+    QVariantList actions;
+
+    // Since we can't have dynamic jump list actions, at least add the user's "Places" for file managers.
+    if (!applicationCategories(launcherUrl).contains(QLatin1String("FileManager"))) {
+        return actions;
+    }
+
+    QString previousGroup;
+    QMenu *subMenu = nullptr;
+
+    std::unique_ptr<KFilePlacesModel> placesModel(new KFilePlacesModel());
+    for (int i = 0; i < placesModel->rowCount(); ++i) {
+        QModelIndex idx = placesModel->index(i, 0);
+
+        if (placesModel->isHidden(idx)) {
+            continue;
+        }
+
+        const QString &title = idx.data(Qt::DisplayRole).toString();
+        const QIcon &icon = idx.data(Qt::DecorationRole).value<QIcon>();
+        const QUrl &url = idx.data(KFilePlacesModel::UrlRole).toUrl();
+
+        QAction *placeAction = new QAction(icon, title, parent);
+
+        connect(placeAction, &QAction::triggered, this, [url, desktopEntryUrl] {
+            KService::Ptr service = KService::serviceByDesktopPath(desktopEntryUrl.toLocalFile());
+            if (!service) {
+                return;
+            }
+
+            auto *job = new KIO::ApplicationLauncherJob(service);
+            auto *delegate = new KNotificationJobUiDelegate;
+            delegate->setAutoErrorHandlingEnabled(true);
+            job->setUiDelegate(delegate);
+
+            job->setUrls({url});
+            job->start();
+        });
+
+        const QString &groupName = idx.data(KFilePlacesModel::GroupRole).toString();
+        if (previousGroup.isEmpty()) { // Skip first group heading.
+            previousGroup = groupName;
+        }
+
+        // Put all subsequent categories into a submenu.
+        if (previousGroup != groupName) {
+            QAction *subMenuAction = new QAction(groupName, parent);
+            subMenu = new QMenu();
+            // Breeze and Oxygen have rounded corners on menus. They set this attribute in polish()
+            // but at that time the underlying surface has already been created where setting this
+            // flag makes no difference anymore (Bug 385311)
+            subMenu->setAttribute(Qt::WA_TranslucentBackground);
+            // Cannot parent a QMenu to a QAction, need to delete it manually.
+            connect(parent, &QObject::destroyed, subMenu, &QObject::deleteLater);
+            subMenuAction->setMenu(subMenu);
+
+            actions << QVariant::fromValue(subMenuAction);
+
+            previousGroup = groupName;
+        }
+
+        if (subMenu) {
+            subMenu->addAction(placeAction);
+        } else {
+            actions << QVariant::fromValue(placeAction);
+        }
+    }
+
+    // There is nothing more frustrating than having a "More" entry that ends up showing just one or two
+    // additional entries. Therefore we truncate to max. 5 entries only if there are more than 7 in total.
+    if (!showAllPlaces && actions.count() > 7) {
+        const int totalActionCount = actions.count();
+
+        while (actions.count() > 5) {
+            actions.removeLast();
+        }
+
+        QAction *action = new QAction(parent);
+        action->setIcon(QIcon::fromTheme(QStringLiteral("view-more-symbolic")));
+        action->setText(i18ncp("Show all user Places", "%1 more Place…", "%1 more Places…", totalActionCount - actions.count()));
+        connect(action, &QAction::triggered, this, &Backend::showAllPlaces);
+        actions << QVariant::fromValue(action);
+    }
+
+    return actions;
+}
+
+QVariantList Backend::recentDocumentActions(const QUrl &launcherUrl, QObject *parent)
+{
+    QVariantList actions;
+    if (!parent) {
+        return actions;
+    }
+
+    if (m_activityManagerPluginsSettings.whatToRemember() == NoApplications) {
+        return actions;
+    }
+
+    QUrl desktopEntryUrl = tryDecodeApplicationsUrl(launcherUrl);
+
+    if (!desktopEntryUrl.isValid() || !desktopEntryUrl.isLocalFile() || !KDesktopFile::isDesktopFile(desktopEntryUrl.toLocalFile())) {
+        return QVariantList();
+    }
+
+    QString desktopName = desktopEntryUrl.fileName();
+    QString storageId = desktopName;
+
+    if (storageId.endsWith(QLatin1String(".desktop"))) {
+        storageId = storageId.left(storageId.length() - 8);
+    }
+
+    auto query = UsedResources | RecentlyUsedFirst | Agent(storageId) | Type::any() | Activity::current();
+
+    ResultSet results(query);
+
+    ResultSet::const_iterator resultIt = results.begin();
+
+    int actionCount = 0;
+
+    bool allFolders = true;
+    bool allDownloads = true;
+    bool allRemoteWithoutFileName = true;
+    const QString downloadsPath = QStandardPaths::writableLocation(QStandardPaths::DownloadLocation);
+
+    while (actionCount < 5 && resultIt != results.end()) {
+        const QString resource = (*resultIt).resource();
+        const QString mimetype = (*resultIt).mimetype();
+        const QUrl url = (*resultIt).url();
+        ++resultIt;
+
+        if (!url.isValid()) {
+            continue;
+        }
+
+        allFolders = allFolders && mimetype == QLatin1String("inode/directory");
+        allDownloads = allDownloads && url.toLocalFile().startsWith(downloadsPath);
+        allRemoteWithoutFileName = allRemoteWithoutFileName && !url.isLocalFile() && url.fileName().isEmpty();
+
+        QString name;
+
+        if (url.isLocalFile() && !url.fileName().isEmpty()) {
+            name = url.fileName();
+        } else {
+            name = url.toDisplayString();
+        }
+
+        QAction *action = new QAction(parent);
+        action->setText(name);
+        action->setIcon(QIcon::fromTheme(KIO::iconNameForUrl(url)));
+        action->setProperty("agent", storageId);
+        action->setProperty("entryPath", desktopEntryUrl);
+        action->setProperty("mimeType", mimetype);
+        action->setData(url);
+        connect(action, &QAction::triggered, this, &Backend::handleRecentDocumentAction);
+
+        actions << QVariant::fromValue<QAction *>(action);
+
+        ++actionCount;
+    }
+
+    if (actionCount > 0) {
+        // Overrides section heading on QML side
+        if (allDownloads) {
+            actions.prepend(i18n("Recent Downloads"));
+        } else if (allRemoteWithoutFileName) {
+            actions.prepend(i18n("Recent Connections"));
+        } else if (allFolders) {
+            actions.prepend(i18n("Recent Places"));
+        }
+
+        QAction *separatorAction = new QAction(parent);
+        separatorAction->setSeparator(true);
+        actions << QVariant::fromValue<QAction *>(separatorAction);
+
+        QAction *action = new QAction(parent);
+        if (allDownloads) {
+            action->setText(i18nc("@action:inmenu", "Forget Recent Downloads"));
+        } else if (allRemoteWithoutFileName) {
+            action->setText(i18nc("@action:inmenu", "Forget Recent Connections"));
+        } else if (allFolders) {
+            action->setText(i18nc("@action:inmenu", "Forget Recent Places"));
+        } else {
+            action->setText(i18nc("@action:inmenu", "Forget Recent Files"));
+        }
+        action->setIcon(QIcon::fromTheme(QStringLiteral("edit-clear-history")));
+        action->setProperty("agent", storageId);
+        connect(action, &QAction::triggered, this, &Backend::handleRecentDocumentAction);
+        actions << QVariant::fromValue<QAction *>(action);
+    }
+
+    return actions;
+}
+
+void Backend::handleRecentDocumentAction() const
+{
+    const QAction *action = qobject_cast<QAction *>(sender());
+
+    if (!action) {
+        return;
+    }
+
+    const QString agent = action->property("agent").toString();
+
+    if (agent.isEmpty()) {
+        return;
+    }
+
+    const QString desktopPath = action->property("entryPath").toUrl().toLocalFile();
+    const QUrl url = action->data().toUrl();
+
+    if (desktopPath.isEmpty() || url.isEmpty()) {
+        auto query = UsedResources | Agent(agent) | Type::any() | Activity::current();
+
+        KAStats::forgetResources(query);
+
+        return;
+    }
+
+    KService::Ptr service = KService::serviceByDesktopPath(desktopPath);
+
+    if (!service) {
+        return;
+    }
+
+    // prevents using a service file that does not support opening a mime type for a file it created
+    // for instance spectacle
+    const auto mimetype = action->property("mimeType").toString();
+    if (!mimetype.isEmpty() && mimetype != QLatin1String("application/octet-stream")) {
+        if (!service->hasMimeType(mimetype)) {
+            // needs to find the application that supports this mimetype
+            service = KApplicationTrader::preferredService(mimetype);
+
+            if (!service) {
+                // no service found to handle the mimetype
+                return;
+            } else {
+                qCWarning(TASKMANAGER_DEBUG) << "Preventing the file to open with " << service->desktopEntryName() << "no alternative found";
+            }
+        }
+    }
+
+    auto *job = new KIO::ApplicationLauncherJob(service);
+    auto *delegate = new KNotificationJobUiDelegate;
+    delegate->setAutoErrorHandlingEnabled(true);
+    job->setUiDelegate(delegate);
+    job->setUrls({url});
+    job->start();
+}
+
+void Backend::setActionGroup(QAction *action) const
+{
+    if (action) {
+        action->setActionGroup(m_actionGroup);
+    }
+}
+
+QRect Backend::globalRect(QQuickItem *item) const
+{
+    if (!item || !item->window()) {
+        return QRect();
+    }
+
+    QRect iconRect(item->x(), item->y(), item->width(), item->height());
+    iconRect.moveTopLeft(item->parentItem()->mapToScene(iconRect.topLeft()).toPoint());
+    iconRect.moveTopLeft(item->window()->mapToGlobal(iconRect.topLeft()));
+
+    return iconRect;
+}
+
+bool Backend::isApplication(const QUrl &url) const
+{
+    if (!url.isValid() || !url.isLocalFile()) {
+        return false;
+    }
+
+    const QString &localPath = url.toLocalFile();
+
+    if (!KDesktopFile::isDesktopFile(localPath)) {
+        return false;
+    }
+
+    KDesktopFile desktopFile(localPath);
+    return desktopFile.hasApplicationType();
+}
+
+qint64 Backend::parentPid(qint64 pid) const
+{
+    KSysGuard::Processes procs;
+    procs.updateOrAddProcess(pid);
+
+    KSysGuard::Process *proc = procs.getProcess(pid);
+    if (!proc) {
+        return -1;
+    }
+
+    int parentPid = proc->parentPid();
+    if (parentPid != -1) {
+        procs.updateOrAddProcess(parentPid);
+
+        KSysGuard::Process *parentProc = procs.getProcess(parentPid);
+        if (!parentProc) {
+            return -1;
+        }
+
+        if (!proc->cGroup().isEmpty() && parentProc->cGroup() == proc->cGroup()) {
+            return parentProc->pid();
+        }
+    }
+
+    return -1;
+}
+
+#include "moc_backend.cpp"
diff --git a/applets/taskmanager_compact/backend.h b/applets/taskmanager_compact/backend.h
new file mode 100644
index 0000000000..c9a30da651
--- /dev/null
+++ b/applets/taskmanager_compact/backend.h
@@ -0,0 +1,81 @@
+/*
+    SPDX-FileCopyrightText: 2013-2016 Eike Hein <hein@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+#pragma once
+
+#include <KConfigWatcher>
+
+#include <QObject>
+#include <QRect>
+
+#include <netwm.h>
+#include <qqmlregistration.h>
+#include <qwindowdefs.h>
+
+#include "kactivitymanagerd_plugins_settings.h"
+
+class QAction;
+class QActionGroup;
+class QQuickItem;
+class QQuickWindow;
+class QJsonArray;
+
+namespace KActivities
+{
+class Consumer;
+}
+
+class Backend : public QObject
+{
+    Q_OBJECT
+    QML_ELEMENT
+
+public:
+    enum MiddleClickAction {
+        None = 0,
+        Close,
+        NewInstance,
+        ToggleMinimized,
+        ToggleGrouping,
+        BringToCurrentDesktop,
+    };
+
+    Q_ENUM(MiddleClickAction)
+
+    explicit Backend(QObject *parent = nullptr);
+    ~Backend() override;
+
+    Q_INVOKABLE QVariantList jumpListActions(const QUrl &launcherUrl, QObject *parent);
+    Q_INVOKABLE QVariantList placesActions(const QUrl &launcherUrl, bool showAllPlaces, QObject *parent);
+    Q_INVOKABLE QVariantList recentDocumentActions(const QUrl &launcherUrl, QObject *parent);
+    Q_INVOKABLE void setActionGroup(QAction *action) const;
+
+    Q_INVOKABLE QRect globalRect(QQuickItem *item) const;
+
+    Q_INVOKABLE bool isApplication(const QUrl &url) const;
+
+    Q_INVOKABLE qint64 parentPid(qint64 pid) const;
+
+    Q_INVOKABLE static QUrl tryDecodeApplicationsUrl(const QUrl &launcherUrl);
+    Q_INVOKABLE static QStringList applicationCategories(const QUrl &launcherUrl);
+
+Q_SIGNALS:
+    void addLauncher(const QUrl &url) const;
+
+    void showAllPlaces();
+
+private Q_SLOTS:
+    void handleRecentDocumentAction() const;
+
+private:
+    QVariantList systemSettingsActions(QObject *parent) const;
+
+    QActionGroup *m_actionGroup = nullptr;
+    KActivities::Consumer *m_activitiesConsumer = nullptr;
+
+    KActivityManagerdPluginsSettings m_activityManagerPluginsSettings;
+    KConfigWatcher::Ptr m_activityManagerPluginsSettingsWatcher;
+};
diff --git a/applets/taskmanager_compact/main.xml b/applets/taskmanager_compact/main.xml
new file mode 100644
index 0000000000..8c3b68785b
--- /dev/null
+++ b/applets/taskmanager_compact/main.xml
@@ -0,0 +1,160 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<kcfg xmlns="http://www.kde.org/standards/kcfg/1.0"
+      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+      xsi:schemaLocation="http://www.kde.org/standards/kcfg/1.0
+      http://www.kde.org/standards/kcfg/1.0/kcfg.xsd" >
+  <kcfgfile name=""/>
+
+  <group name="General">
+    <entry name="showOnlyCurrentScreen" type="Bool">
+      <label>Whether to show only window tasks that are on the same screen as the widget.</label>
+      <default>false</default>
+    </entry>
+    <entry name="showOnlyCurrentDesktop" type="Bool">
+      <label>Whether to only show tasks that are on the current virtual desktop.</label>
+      <default>true</default>
+    </entry>
+    <entry name="showOnlyCurrentActivity" type="Bool">
+      <label>Whether to show only tasks that are on the current activity.</label>
+      <default>true</default>
+    </entry>
+    <entry name="showOnlyMinimized" type="Bool">
+      <label>Whether to show only window tasks that are minmized.</label>
+      <default>false</default>
+    </entry>
+    <entry name="unhideOnAttention" type="Bool">
+      <label>Whether to unhide if a window wants attention.</label>
+      <default>true</default>
+    </entry>
+    <entry name="groupingStrategy" type="Enum">
+      <label>How tasks are grouped: 0 = Do Not Group, 1 = By Program Name</label>
+      <default>1</default>
+    </entry>
+    <entry name="groupedTaskVisualization" type="Enum">
+      <label>What happens when clicking on a grouped task: 0 = cycle through grouped tasks, 1 = try to show tooltips, 2 = try to show present Windows effect, 3 = show textual list (AKA group dialog)</label>
+      <default>0</default>
+    </entry>
+    <entry name="groupPopups" type="Bool">
+      <label>Whether groups are to be reduced to a single task button and expand into a popup or task buttons are grouped on the widget itself.</label>
+      <default>true</default>
+    </entry>
+    <entry name="onlyGroupWhenFull" type="Bool">
+      <label>Whether to group always or only when the widget runs out of space to show additional task buttons comfortably.</label>
+      <default>true</default>
+    </entry>
+    <entry name="groupingAppIdBlacklist" type="StringList">
+      <label>The id's (usually .desktop file names) of applications that should not have their tasks grouped.</label>
+      <default></default>
+    </entry>
+    <entry name="groupingLauncherUrlBlacklist" type="StringList">
+      <label>The launcher URLs (usually .desktop file or executable URLs) of applications that should not have their tasks grouped.</label>
+      <default></default>
+    </entry>
+    <entry name="sortingStrategy" type="Int">
+      <label>Values from TaskManager::TasksModel::SortMode</label>
+      <default>1</default>
+    </entry>
+    <entry name="separateLaunchers" type="Bool">
+      <label>Whether launcher tasks are sorted separately at the left side of the widget or can be mixed with other tasks.</label>
+      <default>true</default>
+    </entry>
+    <entry name="hideLauncherOnStart" type="Bool">
+      <label>Whether launcher tasks should be hidden when their application is launched.</label>
+      <default>true</default>
+    </entry>
+    <entry name="maxStripes" type="Int">
+      <label>The maximum number of rows (in a horizontal-orientation containment, i.e. panel) or columns (in a vertical-orientation containment) to layout task buttons in.</label>
+      <default>1</default>
+      <min>1</min>
+    </entry>
+    <entry name="forceStripes" type="Bool">
+      <label>Whether to try and always layout task buttons in as many rows/columns as set via maxStripes.</label>
+      <default>false</default>
+    </entry>
+    <entry name="showToolTips" type="Bool">
+      <label>Whether to show tooltips when hovering task buttons.</label>
+      <default>true</default>
+    </entry>
+    <entry name="taskMaxWidth" type="Enum">
+      <label>Tune the max width of task items.</label>
+      <choices>
+        <choice name="Narrow"/>
+        <choice name="Medium"/>
+        <choice name="Wide"/>
+      </choices>
+      <default>1</default>
+    </entry>
+    <entry name="wheelEnabled" type="Enum">
+      <label>Whether using the mouse wheel with the mouse pointer above the widget should switch between tasks.</label>
+      <choices>
+        <choice name="None"/>
+        <choice name="AllTask"/>
+        <choice name="TaskOnly"/>
+        <choice name="AdjustVolume"/>
+      </choices>
+      <default>0</default>
+    </entry>
+    <entry name="wheelSkipMinimized" type="Bool">
+      <label>Whether to skip minimized tasks when switching between them using the mouse wheel.</label>
+      <default>true</default>
+    </entry>
+    <entry name="highlightWindows" type="Bool">
+      <label>Whether to request the window manager highlight windows when hovering corresponding task tooltips.</label>
+      <default>false</default>
+    </entry>
+    <entry name="launchers" type="StringList">
+      <label>The list of launcher tasks on the widget. Usually .desktop file or executable URLs. Special URLs such as preferred://browser that expand to default applications are supported.</label>
+      <default>applications:systemsettings.desktop,applications:org.kde.discover.desktop,preferred://filemanager,preferred://browser</default>
+    </entry>
+    <entry name="middleClickAction" type="Enum">
+      <label>What to do on middle-mouse click on a task button.</label>
+      <choices>
+            <choice name="None"/>
+            <choice name="Close"/>
+            <choice name="NewInstance"/>
+            <choice name="ToggleMinimized"/>
+            <choice name="ToggleGrouping"/>
+            <choice name="BringToCurrentDesktop"/>
+      </choices>
+      <default>2</default>
+    </entry>
+    <entry name="indicateAudioStreams" type="Bool">
+      <label>Whether to indicate applications that are playing audio.</label>
+      <default>true</default>
+    </entry>
+    <entry name="interactiveMute" type="Bool">
+      <label>Whether to mute applications that are playing audio using audio indicators.</label>
+      <default>true</default>
+    </entry>
+    <entry name="tooltipControls" type="Bool">
+      <label>Whether to show media and volume controls in the tooltip.</label>
+      <default>true</default>
+    </entry>
+    <entry name="fill" type="Bool">
+      <label>Whether task manager should occupy all available space.</label>
+      <default>true</default>
+    </entry>
+    <entry name="taskHoverEffect" type="Bool">
+      <label>Whether task buttons should change in appearance when the mouse pointer is above them.</label>
+      <default>true</default>
+    </entry>
+    <entry name="maxTextLines" type="Int">
+      <label>The maximum number of text lines to show in a task button. 0 means no limit.</label>
+      <default>0</default>
+    </entry>
+    <entry name="minimizeActiveTaskOnClick" type="Bool">
+      <label>Whether to minimize the currently-active task when clicked. If false, clicking on the currently-active task will do nothing.</label>
+      <default>true</default>
+    </entry>
+    <entry name="reverseMode" type="Bool">
+      <label>Whether to grow the tasks in according to system configuration or opposite to system configuration.</label>
+      <default>false</default>
+    </entry>
+    <entry name="iconSpacing" type="Int">
+      <label> Spacing between icons in task manager. Margin is multiplied by this value.</label>
+      <default>1</default>
+    </entry>
+  </group>
+
+</kcfg>
+
diff --git a/applets/taskmanager_compact/metadata.json b/applets/taskmanager_compact/metadata.json
new file mode 100644
index 0000000000..370ab97a26
--- /dev/null
+++ b/applets/taskmanager_compact/metadata.json
@@ -0,0 +1,166 @@
+{
+    "KPlugin": {
+        "Authors": [
+            {
+                "Email": "hein@kde.org",
+                "Name": "Eike Hein",
+                "Name[ar]": "إيكي هين",
+                "Name[az]": "Eike Hein",
+                "Name[be]": "Eike Hein",
+                "Name[bg]": "Eike Hein",
+                "Name[ca@valencia]": "Eike Hein",
+                "Name[ca]": "Eike Hein",
+                "Name[cs]": "Eike Hein",
+                "Name[da]": "Eike Hein",
+                "Name[de]": "Eike Hein",
+                "Name[el]": "Eike Hein",
+                "Name[en_GB]": "Eike Hein",
+                "Name[eo]": "Eike Hein",
+                "Name[es]": "Eike Hein",
+                "Name[et]": "Eike Hein",
+                "Name[eu]": "Eike Hein",
+                "Name[fi]": "Eike Hein",
+                "Name[fr]": "Eike Hein",
+                "Name[ga]": "Eike Hein",
+                "Name[gl]": "Eike Hein",
+                "Name[he]": "אייק היין",
+                "Name[hu]": "Eike Hein",
+                "Name[ia]": "Eike Hein",
+                "Name[id]": "Eike Hein",
+                "Name[ie]": "Eike Hein",
+                "Name[is]": "Eike Hein",
+                "Name[it]": "Eike Hein",
+                "Name[ja]": "Eike Hein",
+                "Name[ka]": "აიკე ჰაინი",
+                "Name[ko]": "Eike Hein",
+                "Name[lt]": "Eike Hein",
+                "Name[lv]": "Eike Hein",
+                "Name[nb]": "Eike Hein",
+                "Name[nl]": "Eike Hein",
+                "Name[nn]": "Eike Hein",
+                "Name[pa]": "ਇਕੀ ਹੀਇਨ",
+                "Name[pl]": "Eike Hein",
+                "Name[pt]": "Eike Hein",
+                "Name[pt_BR]": "Eike Hein",
+                "Name[ro]": "Eike Hein",
+                "Name[ru]": "Eike Hein",
+                "Name[sa]": "ऐके हेन",
+                "Name[sk]": "Eike Hein",
+                "Name[sl]": "Eike Hein",
+                "Name[sv]": "Eike Hein",
+                "Name[ta]": "எய்கே ஹைன்",
+                "Name[tr]": "Eike Hein",
+                "Name[ug]": "Eike Hein",
+                "Name[uk]": "Eike Hein",
+                "Name[vi]": "Eike Hein",
+                "Name[zh_CN]": "Eike Hein",
+                "Name[zh_TW]": "Eike Hein"
+            }
+        ],
+        "BugReportUrl": "https://bugs.kde.org/enter_bug.cgi?product=plasmashell&component=Task%20Manager%20and%20Icons-Only%20Task%20Manager%20widgets",
+        "Category": "Windows and Tasks",
+        "Description": "Window bar displaying icons and text",
+        "Description[ar]": "شريط نافذة يعرض أيقونات ونص",
+        "Description[az]": "Nişanları və mətni göstərən pəncərə zolağı",
+        "Description[be]": "На панэлі акна паказваюцца значкі і тэкст",
+        "Description[bg]": "Лента на задачите, показваща икони и текст",
+        "Description[ca@valencia]": "Barra de finestres que mostra les icones i text",
+        "Description[ca]": "Barra de finestres que mostra les icones i text",
+        "Description[da]": "Vinduelinje, som viser ikoner og tekst",
+        "Description[de]": "Fensterleiste mit Anzeige von Symbolen und Text",
+        "Description[el]": "Γραμμή παραθύρου που εμφανίζει εικονίδια και κείμενο",
+        "Description[en_GB]": "Window bar displaying icons and text",
+        "Description[eo]": "Fenestrobreto montranta piktogramojn kaj tekston",
+        "Description[es]": "Barra de ventanas que muestra iconos y texto",
+        "Description[eu]": "Leiho-barra, ikonoak eta testua azaltzen dituela",
+        "Description[fi]": "Kuvakkeet ja tekstin näyttävä ikkunapalkki",
+        "Description[fr]": "Barre de fenêtres, avec des icônes et du texte",
+        "Description[ga]": "Barra fuinneoige a thaispeánann deilbhíní agus téacs",
+        "Description[gl]": "Barra de xanelas que amosa iconas e texto.",
+        "Description[he]": "סרגל חלונות המציג סמלים וטקסט",
+        "Description[hu]": "Ikonokat és szöveget megjelenítő ablaksáv",
+        "Description[ia]": "Barra de finestra  monstrante  icones e texto",
+        "Description[id]": "Bilah Jendela menampilkan ikon dan teks",
+        "Description[is]": "Gluggastika sem birtir tákn og texta",
+        "Description[it]": "La barra della finestra che visualizza icone e testo",
+        "Description[ja]": "アイコンとテキストを表示するウィンドウバー",
+        "Description[ka]": "ფანჯრების პანელი, ხატულებსა და ტექსტის ჩვენებით",
+        "Description[ko]": "아이콘과 텍스트를 표시하는 창 표시줄",
+        "Description[lt]": "Langų juosta atvaizduojanti piktogramas ir tekstą",
+        "Description[lv]": "Loga josla ar ikonām un tekstu",
+        "Description[nb]": "Vinduslinje med ikon og tekst",
+        "Description[nl]": "Vensterbalk met pictogrammen en tekst",
+        "Description[nn]": "Vindaugslinje med ikon og tekst",
+        "Description[pl]": "Pasek okna wyświetlający ikony i tekst",
+        "Description[pt]": "Barra de janelas com ícones e texto",
+        "Description[pt_BR]": "Seletor de janelas estilo barra de tarefas mostrando ícones e texto",
+        "Description[ro]": "Bară cu ferestre afișând pictograme și text",
+        "Description[ru]": "Панель переключения окон, использующая значки и текст",
+        "Description[sa]": "चिह्नानि पाठं च प्रदर्शयति इति विण्डोबार",
+        "Description[sk]": "Prepínač okien zobrazujúci ikony a text",
+        "Description[sl]": "Vrstica oken, ki prikazuje ikone in besedilo",
+        "Description[sv]": "Fönsterrad som visar ikoner och text",
+        "Description[ta]": "சின்னங்களையும் பெயர்களையும் காட்டும் பணிப்பட்டை",
+        "Description[tr]": "Simge ve metin görüntüleyen pencere çubuğu",
+        "Description[ug]": "كۆزنەك بالداقتا سىنبەلگە ۋە تېكىست كۆرسىتىدۇ",
+        "Description[uk]": "Панель вікон із показаними піктограмами і текстом",
+        "Description[zh_CN]": "窗口栏显示图标和文本",
+        "Description[zh_TW]": "顯示圖示與文字的視窗列",
+        "EnabledByDefault": true,
+        "Icon": "preferences-system-windows",
+        "License": "GPL-2.0+",
+        "Name": "Icons-and-Text Task Manager (Compact)",
+        "Name[ar]": "مدير مهامّ بأيقونات ونص",
+        "Name[az]": "Tapşırıq menecerinin nişanı və mətni",
+        "Name[be]": "Выгляд кіраўніка задач",
+        "Name[bg]": "Мениджър на задачи (икони с текст)",
+        "Name[ca@valencia]": "Gestor de tasques amb icones i text",
+        "Name[ca]": "Gestor de tasques amb icones i text",
+        "Name[da]": "Opgavelinje kun med ikoner og tekst",
+        "Name[de]": "Fensterleiste mit Symbolen und Text",
+        "Name[el]": "Διαχείριση εργασιών με εικονίδια και κείμενο",
+        "Name[en_GB]": "Icons-and-Text Task Manager",
+        "Name[eo]": "Piktogram-kaj-Teksta Taskadministrilo",
+        "Name[es]": "Gestor de tareas con iconos y texto",
+        "Name[eu]": "Ikonoak-eta-Testua dituen ataza-kudeatzailea",
+        "Name[fi]": "Kuvakkeet ja teksti -tehtävienhallinta",
+        "Name[fr]": "Gestionnaire de tâches avec icônes et du texte",
+        "Name[ga]": "Bainisteoir Tascanna Deilbhíní agus Téacs",
+        "Name[gl]": "Xestor de tarefas de só iconas e texto",
+        "Name[he]": "מנהל משימות של סמלים וטקסט בלבד",
+        "Name[hu]": "Ikonos és szöveges feladatkezelő",
+        "Name[ia]": "Gerente de carga de icone-e-texto",
+        "Name[id]": "Pengelola Tugas Ikon dan Teks",
+        "Name[is]": "Verkefnastjóri með táknum og texta",
+        "Name[it]": "Gestore dei processi solo icone e testo",
+        "Name[ja]": "アイコンだけのタスクマネージャ",
+        "Name[ka]": "ხატულებიანი-და-ტექსტიანი ამოცანების მმართველი",
+        "Name[ko]": "아이콘과 텍스트 작업 관리자",
+        "Name[lt]": "Piktogramų ir teksto užduočių tvarkytuvė",
+        "Name[lv]": "Ikonu un teksta uzdevumu pārvaldnieks",
+        "Name[nb]": "Oppgavebehandler med bare ikoner og tekst",
+        "Name[nl]": "Takenbeheer met pictogrammen-en-tekst",
+        "Name[nn]": "Oppgåve­handsamar med ikon og tekst",
+        "Name[pa]": "ਆਈਕਾਨ-ਤੇ-ਲਿਖਤ ਟਾਸਕ ਮੈਨੇਜਰ",
+        "Name[pl]": "Ikonowo-tekstowy przełącznik zadań",
+        "Name[pt]": "Barra de tarefas (texto e ícones)",
+        "Name[pt_BR]": "Gerenciador de tarefas com ícones e texto",
+        "Name[ro]": "Gestionar de sarcini cu pictograme și text",
+        "Name[ru]": "Панель задач (значки и текст)",
+        "Name[sa]": "चिह्न-पाठ-कार्य-प्रबन्धकः",
+        "Name[sk]": "Správca úloh s ikonami a textom",
+        "Name[sl]": "Upravljalnik opravil z ikonami in besedili",
+        "Name[sv]": "Aktivitetshanterare med ikoner och text",
+        "Name[ta]": "சின்னங்கள்-மற்றும்-உரை பணி மேலாளி",
+        "Name[tr]": "Simgeli ve Etiketli Görev Yöneticisi",
+        "Name[ug]": "سىنبەلگە ۋە تېكىست ۋەزىپە باشقۇرغۇچ",
+        "Name[uk]": "Керування задачами з піктограмами і текстом",
+        "Name[zh_CN]": "图标和文本任务管理器",
+        "Name[zh_TW]": "僅圖示與文字的工作管理員",
+        "Website": "https://userbase.kde.org/Plasma/Tasks"
+    },
+    "X-Plasma-API-Minimum-Version": "6.0",
+    "X-Plasma-Provides": [
+        "org.kde.plasma.multitasking"
+    ]
+}
diff --git a/applets/taskmanager_compact/qml/AudioStream.qml b/applets/taskmanager_compact/qml/AudioStream.qml
new file mode 100644
index 0000000000..a122f07b6a
--- /dev/null
+++ b/applets/taskmanager_compact/qml/AudioStream.qml
@@ -0,0 +1,182 @@
+/*
+    SPDX-FileCopyrightText: 2017 Kai Uwe Broulik <kde@privat.broulik.de>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+import QtQuick
+
+import org.kde.plasma.plasmoid
+import org.kde.plasma.extras as PlasmaExtras
+import org.kde.kirigami as Kirigami
+import org.kde.ksvg as KSvg
+
+Item {
+    id: audioStreamIconBox
+
+    width: Math.round(Math.min(Math.min(iconBox.width, iconBox.height) * 0.4, Kirigami.Units.iconSizes.smallMedium))
+    height: width
+    anchors {
+        top: frame.top
+        right: frame.right
+        rightMargin: taskFrame.margins.right
+        topMargin: Math.round(taskFrame.margins.top * indicatorScale)
+    }
+
+    readonly property real indicatorScale: 1.2
+
+    activeFocusOnTab: true
+
+    // Using States rather than a simple Behavior we can apply different transitions,
+    // which allows us to delay showing the icon but hide it instantly still.
+    states: [
+        State {
+            name: "playing"
+            when: task.playingAudio && !task.muted
+            PropertyChanges {
+                audioStreamIconBox.opacity: 1
+                audioStreamIcon.source: "audio-volume-high-symbolic" + (Application.layoutDirection === Qt.RightToLeft ? "-rtl" : "")
+            }
+        },
+        State {
+            name: "muted"
+            when: task.muted
+            PropertyChanges {
+                audioStreamIconBox.opacity: 1
+                audioStreamIcon.source: "audio-volume-muted-symbolic" + (Application.layoutDirection === Qt.RightToLeft ? "-rtl" : "")
+            }
+        }
+    ]
+
+    transitions: [
+        Transition {
+             from: ""
+             to: "playing"
+             SequentialAnimation {
+                 // Delay showing the play indicator so we don't flash it for brief sounds.
+                 PauseAnimation {
+                     duration: !task.delayAudioStreamIndicator || inPopup ? 0 : 2000
+                 }
+                 NumberAnimation {
+                     property: "opacity"
+                     duration: Kirigami.Units.longDuration
+                 }
+             }
+        },
+        Transition {
+             from: ""
+             to: "muted"
+             SequentialAnimation {
+                 NumberAnimation {
+                     property: "opacity"
+                     duration: Kirigami.Units.longDuration
+                 }
+             }
+        },
+        Transition {
+             to: ""
+             NumberAnimation {
+                 property: "opacity"
+                 duration: Kirigami.Units.longDuration
+             }
+        }
+    ]
+
+    opacity: 0
+    visible: opacity > 0
+
+    Keys.onReturnPressed: event => toggleMuted()
+    Keys.onEnterPressed: event => Keys.returnPressed(event);
+    Keys.onSpacePressed: event => Keys.returnPressed(event);
+
+    Accessible.checkable: true
+    Accessible.checked: task.muted
+    Accessible.name: task.muted ? i18nc("@action:button", "Unmute") : i18nc("@action:button", "Mute")
+    Accessible.description: task.muted ? i18nc("@info:tooltip %1 is the window title", "Unmute %1", model.display) : i18nc("@info:tooltip %1 is the window title", "Mute %1", model.display)
+    Accessible.role: Accessible.Button
+
+    HoverHandler {
+        id: hoverHandler
+        enabled: Plasmoid.configuration.interactiveMute
+    }
+
+    TapHandler {
+        id: tapHandler
+        gesturePolicy: TapHandler.ReleaseWithinBounds // Exclusive grab
+        enabled: Plasmoid.configuration.interactiveMute
+        onTapped: (eventPoint, button) => toggleMuted()
+    }
+
+    PlasmaExtras.Highlight {
+        anchors.fill: audioStreamIcon
+        hovered: hoverHandler.hovered || parent.activeFocus
+        pressed: tapHandler.pressed
+    }
+
+    Kirigami.Icon {
+        id: audioStreamIcon
+
+        // Need audio indicator twice, to keep iconBox in the center.
+        readonly property real requiredSpace: Math.min(iconBox.width, iconBox.height)
+            + Math.min(Math.min(iconBox.width, iconBox.height), Kirigami.Units.iconSizes.smallMedium) * 2
+
+        source: "audio-volume-high-symbolic" + (Application.layoutDirection === Qt.RightToLeft ? "-rtl" : "")
+        selected: tapHandler.pressed
+
+        height: Math.round(Math.min(parent.height * audioStreamIconBox.indicatorScale, Kirigami.Units.iconSizes.smallMedium))
+        width: height
+
+        anchors {
+            verticalCenter: parent.verticalCenter
+            horizontalCenter: parent.horizontalCenter
+        }
+
+        states: [
+            State {
+                name: "verticalIconsOnly"
+                when: tasks.vertical && frame.width < audioStreamIcon.requiredSpace
+
+                PropertyChanges {
+                    audioStreamIconBox.anchors.rightMargin: Math.round(taskFrame.margins.right * indicatorScale)
+                }
+            },
+
+            State {
+                name: "horizontal"
+                when: frame.width > audioStreamIcon.requiredSpace
+
+                AnchorChanges {
+                    target: audioStreamIconBox
+
+                    anchors.top: undefined
+                    anchors.verticalCenter: frame.verticalCenter
+                }
+
+                PropertyChanges {
+                    audioStreamIconBox.width: Kirigami.Units.iconSizes.roundedIconSize(Math.min(Math.min(iconBox.width, iconBox.height), Kirigami.Units.iconSizes.smallMedium))
+                    audioStreamIcon.height: audioStreamIcon.parent.height
+                    audioStreamIcon.width: audioStreamIcon.parent.width
+                }
+            },
+
+            State {
+                name: "vertical"
+                when: frame.height > audioStreamIcon.requiredSpace
+
+                AnchorChanges {
+                    target: audioStreamIconBox
+
+                    anchors.right: undefined
+                    anchors.horizontalCenter: frame.horizontalCenter
+                }
+
+                PropertyChanges {
+                    audioStreamIconBox.anchors.topMargin: taskFrame.margins.top
+                    audioStreamIconBox.width: Kirigami.Units.iconSizes.roundedIconSize(Math.min(Math.min(iconBox.width, iconBox.height), Kirigami.Units.iconSizes.smallMedium))
+                    audioStreamIcon.height: audioStreamIcon.parent.height
+                    audioStreamIcon.width: audioStreamIcon.parent.width
+                }
+            }
+        ]
+    }
+}
diff --git a/applets/taskmanager_compact/qml/Badge.qml b/applets/taskmanager_compact/qml/Badge.qml
new file mode 100644
index 0000000000..eec0d2921c
--- /dev/null
+++ b/applets/taskmanager_compact/qml/Badge.qml
@@ -0,0 +1,59 @@
+/*
+    SPDX-FileCopyrightText: 2018 Kai Uwe Broulik <kde@privat.broulik.de>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+import QtQuick
+
+import org.kde.plasma.components as PlasmaComponents3
+import org.kde.kirigami as Kirigami
+
+// This top-level item is an opaque background that goes behind the colored
+// background, for contrast. It's not an Item since that it would be square,
+// and not round, as required here
+Rectangle {
+    id: badgeRect
+
+    property alias text: label.text
+    property alias textColor: label.color
+    property int number: 0
+
+    implicitWidth: Math.max(height, Math.round(label.contentWidth + radius / 2)) // Add some padding around.
+    implicitHeight: implicitWidth
+
+    radius: height / 2
+
+    color: Kirigami.Theme.backgroundColor
+
+    // Colored background
+    Rectangle {
+        anchors.fill: parent
+        radius: height / 2
+
+        color: Qt.alpha(Kirigami.Theme.highlightColor, 0.3)
+        border.color: Kirigami.Theme.highlightColor
+        border.width: 1
+    }
+
+    // Number
+    PlasmaComponents3.Label {
+        id: label
+        anchors.centerIn: parent
+        width: height
+        height: Math.min(Kirigami.Units.gridUnit * 2, Math.round(parent.height))
+        horizontalAlignment: Text.AlignHCenter
+        verticalAlignment: Text.AlignVCenter
+        fontSizeMode: Text.VerticalFit
+        font.pointSize: 1024
+        minimumPointSize: 5
+        text: {
+            if (badgeRect.number > 9999) {
+                return i18nc("Over 9999 new messages, overlay, keep short", "9,999+");
+            } else {
+                return badgeRect.number.toLocaleString(Qt.locale(), 'f', 0);
+            }
+        }
+        textFormat: Text.PlainText
+    }
+}
diff --git a/applets/taskmanager_compact/qml/ConfigAppearance.qml b/applets/taskmanager_compact/qml/ConfigAppearance.qml
new file mode 100644
index 0000000000..7eaac11f64
--- /dev/null
+++ b/applets/taskmanager_compact/qml/ConfigAppearance.qml
@@ -0,0 +1,201 @@
+/*
+    SPDX-FileCopyrightText: 2013 Eike Hein <hein@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+import QtQuick
+import QtQuick.Controls as QQC2
+
+import org.kde.kcmutils as KCMUtils
+import org.kde.kirigami as Kirigami
+import org.kde.plasma.core as PlasmaCore
+import org.kde.plasma.plasmoid
+
+KCMUtils.SimpleKCM {
+    id: root
+
+    readonly property bool plasmaPaAvailable: Qt.createComponent("PulseAudio.qml").status === Component.Ready
+    readonly property bool plasmoidVertical: Plasmoid.formFactor === PlasmaCore.Types.Vertical
+    readonly property bool iconOnly: Plasmoid.pluginName === "org.kde.plasma.icontasks"
+
+    property alias cfg_showToolTips: showToolTips.checked
+    property alias cfg_highlightWindows: highlightWindows.checked
+    property bool cfg_indicateAudioStreams
+    property bool cfg_interactiveMute
+    property bool cfg_tooltipControls
+    property alias cfg_fill: fill.checked
+    property alias cfg_maxStripes: maxStripes.value
+    property alias cfg_forceStripes: forceStripes.checked
+    property alias cfg_taskMaxWidth: taskMaxWidth.currentIndex
+    property int cfg_iconSpacing: 0
+
+    Component.onCompleted: {
+        /* Don't rely on bindings for checking the radiobuttons
+           When checking forceStripes, the condition for the checked value for the allow stripes button
+           became true and that one got checked instead, stealing the checked state for the just clicked checkbox
+        */
+        if (maxStripes.value === 1) {
+            forbidStripes.checked = true;
+        } else if (!Plasmoid.configuration.forceStripes && maxStripes.value > 1) {
+            allowStripes.checked = true;
+        } else if (Plasmoid.configuration.forceStripes && maxStripes.value > 1) {
+            forceStripes.checked = true;
+        }
+    }
+    Kirigami.FormLayout {
+        QQC2.CheckBox {
+            id: showToolTips
+            Kirigami.FormData.label: i18nc("@label for several checkboxes", "General:")
+            text: i18nc("@option:check section General", "Show small window previews when hovering over tasks")
+        }
+
+        QQC2.CheckBox {
+            id: highlightWindows
+            text: showToolTips.checked ? i18nc("@option:check section General", "Hide other windows when hovering over previews") : i18nc("@option:check section General", "Hide other windows when hovering over tooltips")
+        }
+
+        QQC2.CheckBox {
+            id: indicateAudioStreams
+            text: i18nc("@option:check section General", "Show an indicator when a task is playing audio")
+            checked: root.cfg_indicateAudioStreams && root.plasmaPaAvailable
+            onToggled: root.cfg_indicateAudioStreams = checked
+            enabled: root.plasmaPaAvailable
+        }
+
+        QQC2.CheckBox {
+            id: interactiveMute
+            leftPadding: mirrored ? 0 : (indicateAudioStreams.indicator.width + indicateAudioStreams.spacing)
+            rightPadding: mirrored ? (indicateAudioStreams.indicator.width + indicateAudioStreams.spacing) : 0
+            text: i18nc("@option:check section General", "Mute task when clicking indicator")
+            checked: root.cfg_interactiveMute && root.plasmaPaAvailable
+            onToggled: root.cfg_interactiveMute = checked
+            enabled: indicateAudioStreams.checked && root.plasmaPaAvailable
+        }
+
+        QQC2.CheckBox {
+            id: tooltipControls
+            text: i18nc("@option:check section General", "Show media and volume controls in tooltip")
+            checked: root.cfg_tooltipControls && root.plasmaPaAvailable
+            onToggled: root.cfg_tooltipControls = checked
+            enabled: root.plasmaPaAvailable
+        }
+
+        QQC2.CheckBox {
+            id: fill
+            text: i18nc("@option:check section General", "Fill free space on panel")
+        }
+
+        Item {
+            Kirigami.FormData.isSection: true
+            visible: !root.iconOnly
+        }
+
+        QQC2.ComboBox {
+            id: taskMaxWidth
+            visible: !root.iconOnly && !root.plasmoidVertical
+
+            Kirigami.FormData.label: i18nc("@label:listbox", "Maximum task width:")
+
+            model: [
+                i18nc("@item:inlistbox how wide a task item should be", "Narrow"),
+                i18nc("@item:inlistbox how wide a task item should be", "Medium"),
+                i18nc("@item:inlistbox how wide a task item should be", "Wide")
+            ]
+        }
+
+        Item {
+            Kirigami.FormData.isSection: true
+        }
+
+        QQC2.RadioButton {
+            id: forbidStripes
+            Kirigami.FormData.label: root.plasmoidVertical
+                ? i18nc("@label for radio button group, completes sentence: … when panel is low on space etc.", "Use multi-column view:")
+                : i18nc("@label for radio button group, completes sentence: … when panel is low on space etc.", "Use multi-row view:")
+            onToggled: {
+                if (checked) {
+                    maxStripes.value = 1
+                }
+            }
+            text: i18nc("@option:radio Never use multi-column view for Task Manager", "Never")
+        }
+
+        QQC2.RadioButton {
+            id: allowStripes
+            onToggled: {
+                if (checked) {
+                    maxStripes.value = Math.max(2, maxStripes.value)
+                }
+            }
+            text: i18nc("@option:radio completes sentence: Use multi-column/row view", "When panel is low on space and thick enough")
+        }
+
+        QQC2.RadioButton {
+            id: forceStripes
+            onToggled: {
+                if (checked) {
+                    maxStripes.value = Math.max(2, maxStripes.value)
+                }
+            }
+            text: i18nc("@option:radio completes sentence: Use multi-column/row view", "Always when panel is thick enough")
+        }
+
+        QQC2.SpinBox {
+            id: maxStripes
+            enabled: maxStripes.value > 1
+            Kirigami.FormData.label: root.plasmoidVertical
+                ? i18nc("@label:spinbox maximum number of columns for tasks", "Maximum columns:")
+                : i18nc("@label:spinbox maximum number of rows for tasks", "Maximum rows:")
+            from: 1
+        }
+
+        Item {
+            Kirigami.FormData.isSection: true
+        }
+
+        QQC2.ComboBox {
+            visible: root.iconOnly
+            Kirigami.FormData.label: i18nc("@label:listbox", "Spacing between icons:")
+
+            model: [
+                {
+                    "label": i18nc("@item:inlistbox Icon spacing", "Small"),
+                    "spacing": 0
+                },
+                {
+                    "label": i18nc("@item:inlistbox Icon spacing", "Normal"),
+                    "spacing": 1
+                },
+                {
+                    "label": i18nc("@item:inlistbox Icon spacing", "Large"),
+                    "spacing": 3
+                },
+            ]
+
+            textRole: "label"
+            enabled: !Kirigami.Settings.tabletMode
+
+            currentIndex: {
+                if (Kirigami.Settings.tabletMode) {
+                    return 2; // Large
+                }
+
+                switch (root.cfg_iconSpacing) {
+                    case 0: return 0; // Small
+                    case 1: return 1; // Normal
+                    case 3: return 2; // Large
+                }
+            }
+            onActivated: index => {
+                root.cfg_iconSpacing = model[currentIndex]["spacing"];
+            }
+        }
+
+        QQC2.Label {
+            visible: Kirigami.Settings.tabletMode
+            text: i18nc("@info:usagetip under a set of radio buttons when Touch Mode is on", "Automatically set to Large when in Touch mode")
+            font: Kirigami.Theme.smallFont
+        }
+    }
+}
diff --git a/applets/taskmanager_compact/qml/ConfigBehavior.qml b/applets/taskmanager_compact/qml/ConfigBehavior.qml
new file mode 100644
index 0000000000..bd4b7cf008
--- /dev/null
+++ b/applets/taskmanager_compact/qml/ConfigBehavior.qml
@@ -0,0 +1,306 @@
+/*
+    SPDX-FileCopyrightText: 2013 Eike Hein <hein@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+import QtQuick
+import QtQuick.Controls as QQC2
+import QtQuick.Layouts
+
+import org.kde.kcmutils as KCMUtils
+import org.kde.kirigami as Kirigami
+import org.kde.plasma.core as PlasmaCore
+import org.kde.plasma.plasmoid
+
+import org.kde.plasma.workspace.dbus as DBus
+import org.kde.taskmanager as TaskManager
+
+KCMUtils.SimpleKCM {
+    id: root
+
+    property alias cfg_groupingStrategy: groupingStrategy.currentIndex
+    property alias cfg_groupedTaskVisualization: groupedTaskVisualization.currentIndex
+    property alias cfg_groupPopups: groupPopups.checked
+    property alias cfg_onlyGroupWhenFull: onlyGroupWhenFull.checked
+    property int cfg_sortingStrategy
+    property alias cfg_separateLaunchers: separateLaunchers.checked
+    property alias cfg_hideLauncherOnStart: hideLauncherOnStart.checked
+    property alias cfg_middleClickAction: middleClickAction.currentIndex
+    property alias cfg_wheelEnabled: wheelEnabled.currentIndex
+    property alias cfg_wheelSkipMinimized: wheelSkipMinimized.checked
+    property alias cfg_showOnlyCurrentScreen: showOnlyCurrentScreen.checked
+    property alias cfg_showOnlyCurrentDesktop: showOnlyCurrentDesktop.checked
+    property alias cfg_showOnlyCurrentActivity: showOnlyCurrentActivity.checked
+    property alias cfg_showOnlyMinimized: showOnlyMinimized.checked
+    property alias cfg_minimizeActiveTaskOnClick: minimizeActive.checked
+    property alias cfg_unhideOnAttention: unhideOnAttention.checked
+    property alias cfg_reverseMode: reverseMode.checked
+
+    headerPaddingEnabled: false
+    header: ColumnLayout {
+        spacing: Kirigami.Units.smallSpacing
+
+        Kirigami.InlineMessage {
+            id: annoyingAppWorkaroundMessage
+
+            Layout.fillWidth: true
+            position: Kirigami.InlineMessage.Position.Header
+
+            text: i18nc("@info", "If you're using this setting to work around an application that demands attention too often, first look for a setting in the app to disable that behavior. If you don't find one, consider reporting this as a bug to the app's developer.")
+        }
+    }
+
+    DBus.DBusServiceWatcher {
+        id: effectWatcher
+        busType: DBus.BusType.Session
+        watchedService: "org.kde.KWin.Effect.WindowView1"
+    }
+
+    Kirigami.FormLayout {
+        anchors.left: parent.left
+        anchors.right: parent.right
+
+        QQC2.ComboBox {
+            id: groupingStrategy
+            Kirigami.FormData.label: i18nc("@label:listbox how to group tasks", "Group:")
+            Layout.fillWidth: true
+            Layout.minimumWidth: Kirigami.Units.gridUnit * 14
+            model: [
+                i18nc("@item:inlistbox how to group tasks", "Do not group"),
+                i18nc("@item:inlistbox how to group tasks", "By program name")
+            ]
+        }
+
+        QQC2.ComboBox {
+            id: groupedTaskVisualization
+            Kirigami.FormData.label: i18nc("@label:listbox completes sentence like: … cycles through tasks", "Clicking grouped task:")
+            Layout.fillWidth: true
+            Layout.minimumWidth: Kirigami.Units.gridUnit * 14
+
+            enabled: groupingStrategy.currentIndex !== 0
+
+            model: [
+                i18nc("@item:inlistbox Completes the sentence 'Clicking grouped task cycles through tasks' ", "Cycles through tasks"),
+                i18nc("@item:inlistbox Completes the sentence 'Clicking grouped task shows small window previews' ", "Shows small window previews"),
+                i18nc("@item:inlistbox Completes the sentence 'Clicking grouped task shows large window previews' ", "Shows large window previews"),
+                i18nc("@item:inlistbox Completes the sentence 'Clicking grouped task shows textual list' ", "Shows textual list"),
+            ]
+
+            Accessible.name: currentText
+            Accessible.onPressAction: currentIndex = currentIndex === count - 1 ? 0 : (currentIndex + 1)
+        }
+        // "You asked for Window View but Window View is not available" message
+        Kirigami.InlineMessage {
+            Layout.fillWidth: true
+            visible: groupedTaskVisualization.currentIndex === 2 && !effectWatcher.registered
+            type: Kirigami.MessageType.Warning
+            text: i18nc("@info displayed as InlineMessage", "The compositor does not support displaying windows side by side, so a textual list will be displayed instead.")
+        }
+
+        Item {
+            Kirigami.FormData.isSection: true
+        }
+
+        QQC2.CheckBox {
+            id: groupPopups
+            visible: (Plasmoid.pluginName !== "org.kde.plasma.icontasks")
+            text: i18nc("@option:check grouped task", "Combine into single button")
+            enabled: groupingStrategy.currentIndex > 0
+        }
+
+        QQC2.CheckBox {
+            id: onlyGroupWhenFull
+            visible: (Plasmoid.pluginName !== "org.kde.plasma.icontasks")
+            text: i18nc("@option:check grouped task","Group only when the Task Manager is full")
+            enabled: groupingStrategy.currentIndex > 0 && groupPopups.checked
+            Accessible.onPressAction: toggle()
+        }
+
+        Item {
+            Kirigami.FormData.isSection: true
+            visible: (Plasmoid.pluginName !== "org.kde.plasma.icontasks")
+        }
+
+        QQC2.ComboBox {
+            id: sortingStrategy
+            Kirigami.FormData.label: i18nc("@label:listbox sort tasks in grouped task", "Sort:")
+            Layout.fillWidth: true
+            Layout.minimumWidth: Kirigami.Units.gridUnit * 14
+            textRole: "text"
+            valueRole: "value"
+            model: [
+                {
+                    "text": i18nc("@item:inlistbox sort tasks in grouped task", "Do not sort"),
+                    "value": TaskManager.TasksModel.SortDisabled,
+                },
+                {
+                    "text": i18nc("@item:inlistbox sort tasks in grouped task", "Manually"),
+                    "value": TaskManager.TasksModel.SortManual,
+                },
+                {
+                    "text": i18nc("@item:inlistbox sort tasks in grouped task", "Alphabetically"),
+                    "value": TaskManager.TasksModel.SortAlpha,
+                },
+                {
+                    "text": i18nc("@item:inlistbox sort tasks in grouped task", "By desktop"),
+                    "value": TaskManager.TasksModel.SortVirtualDesktop,
+                },
+                {
+                    "text": i18nc("@item:inlistbox sort tasks in grouped task", "By activity"),
+                    "value": TaskManager.TasksModel.SortActivity,
+                },
+                {
+                    "text": i18nc("@item:inlistbox sort tasks in grouped task", "By horizontal window position"),
+                    "value": TaskManager.TasksModel.SortWindowPositionHorizontal,
+                },
+            ]
+            onActivated: root.cfg_sortingStrategy = currentValue
+            Component.onCompleted: currentIndex = indexOfValue(root.cfg_sortingStrategy)
+        }
+
+        QQC2.CheckBox {
+            id: separateLaunchers
+            visible: (Plasmoid.pluginName !== "org.kde.plasma.icontasks")
+            text: i18nc("@option:check configure task sorting", "Keep launchers separate")
+            enabled: sortingStrategy.currentValue === TaskManager.TasksModel.SortManual
+        }
+
+        QQC2.CheckBox {
+            id: hideLauncherOnStart
+            visible: (Plasmoid.pluginName !== "org.kde.plasma.icontasks")
+            text: i18nc("@option:check for icons-and-text task manager", "Hide launchers after application startup")
+        }
+
+        Item {
+            Kirigami.FormData.isSection: true
+            visible: (Plasmoid.pluginName !== "org.kde.plasma.icontasks")
+        }
+
+        QQC2.CheckBox {
+            id: minimizeActive
+            Kirigami.FormData.label: i18nc("@label for checkbox Part of a sentence: 'Clicking active task minimizes the task'", "Clicking active task:")
+            text: i18nc("@option:check Part of a sentence: 'Clicking active task minimizes the task'", "Minimizes the task")
+        }
+
+        QQC2.ComboBox {
+            id: middleClickAction
+            Kirigami.FormData.label: i18nc("@label:listbox completes sentence like: … does nothing", "Middle-clicking any task:")
+            Layout.fillWidth: true
+            Layout.minimumWidth: Kirigami.Units.gridUnit * 14
+            model: [
+                i18nc("@item:inlistbox Part of a sentence: 'Middle-clicking any task does nothing'", "Does nothing"),
+                i18nc("@item:inlistbox Part of a sentence: 'Middle-clicking any task closes window or group'", "Closes window or group"),
+                i18nc("@item:inlistbox Part of a sentence: 'Middle-clicking any task opens a new window'", "Opens a new window"),
+                i18nc("@item:inlistbox Part of a sentence: 'Middle-clicking any task minimizes/restores window or group'", "Minimizes/Restores window or group"),
+                i18nc("@item:inlistbox Part of a sentence: 'Middle-clicking any task toggles grouping'", "Toggles grouping"),
+                i18nc("@item:inlistbox Part of a sentence: 'Middle-clicking any task brings it to the current virtual desktop'", "Brings it to the current virtual desktop")
+            ]
+        }
+
+        Item {
+            Kirigami.FormData.isSection: true
+        }
+
+        QQC2.ComboBox {
+            id: wheelEnabled
+            Kirigami.FormData.label: i18nc("@label:listbox Part of a sentence: 'Scrolling behavior does nothing/cycles through tasks/cycles through the selected task's windows/adjusts the hovered task’s volume''", "Scrolling behavior:")
+            Layout.fillWidth: true
+            Layout.minimumWidth: Kirigami.Units.gridUnit * 14
+            model: [
+                i18nc("@item:inlistbox Part of a sentence: 'Scrolling behavior does nothing'", "Does nothing"),
+                i18nc("@item:inlistbox Part of a sentence: 'Scrolling behavior cycles through all tasks'", "Cycles through all tasks"),
+                i18nc("@item:inlistbox Part of a sentence: 'Scrolling behavior cycles through the hovered task's windows'", "Cycles through the hovered task’s windows"),
+                i18nc("@item:inlistbox Part of a sentence: 'Scrolling behavior adjusts the hovered task’s volume'", "Adjusts the hovered task’s volume"),
+            ]
+        }
+
+        QQC2.CheckBox {
+            id: wheelSkipMinimized
+            leftPadding: mirrored ? 0 : (wheelEnabled.indicator.width + wheelEnabled.spacing)
+            rightPadding: mirrored ? (wheelEnabled.indicator.width + wheelEnabled.spacing) : 0
+            text: i18nc("@option:check mouse wheel task cycling", "Skip minimized tasks")
+            enabled: wheelEnabled.currentIndex !== 0 // None
+        }
+
+        Item {
+            Kirigami.FormData.isSection: true
+        }
+
+        QQC2.CheckBox {
+            id: showOnlyCurrentDesktop
+            Kirigami.FormData.label: i18nc("@label for checkbox group, completes sentence like: … from current screen", "Show only tasks:")
+            text: i18nc("@option:check completes sentence: show only tasks", "From the current desktop")
+        }
+
+        QQC2.CheckBox {
+            id: showOnlyCurrentActivity
+            text: i18nc("@option:check completes sentence: show only tasks", "From the current activity")
+        }
+
+        QQC2.CheckBox {
+            id: showOnlyCurrentScreen
+            text: i18nc("@option:check completes sentence: show only tasks", "From the current screen")
+        }
+
+        QQC2.CheckBox {
+            id: showOnlyMinimized
+            text: i18nc("@option:check completes sentence: show only tasks", "That are minimized")
+        }
+
+        Item {
+            Kirigami.FormData.isSection: true
+        }
+
+        QQC2.CheckBox {
+            id: unhideOnAttention
+            Kirigami.FormData.label: i18nc("@label for checkbox, completes sentence: … unhide if window wants attention", "When panel is hidden:")
+            text: i18nc("@option:check completes sentence: When panel is hidden", "Unhide when a window wants attention")
+            onToggled: {
+                annoyingAppWorkaroundMessage.visible = !unhideOnAttention.checked;
+            }
+        }
+
+        Item {
+            Kirigami.FormData.isSection: true
+        }
+
+        QQC2.ButtonGroup {
+            id: reverseModeRadioButtonGroup
+        }
+
+        QQC2.RadioButton {
+            Kirigami.FormData.label: i18nc("@label for radiobutton group completes sentence like: … on the bottom", "New tasks appear:")
+            checked: !reverseMode.checked
+            text: {
+                if (Plasmoid.formFactor === PlasmaCore.Types.Vertical) {
+                    return i18nc("@option:check completes sentence: New tasks appear", "On the bottom")
+                }
+                // horizontal
+                if (Application.layoutDirection === Qt.LeftToRight) {
+                    return i18nc("@option:check completes sentence: New tasks appear", "To the right");
+                } else {
+                    return i18nc("@option:check completes sentence: New tasks appear", "To the left")
+                }
+            }
+            QQC2.ButtonGroup.group: reverseModeRadioButtonGroup
+        }
+
+        QQC2.RadioButton {
+            id: reverseMode
+            checked: Plasmoid.configuration.reverseMode === true
+            text: {
+                if (Plasmoid.formFactor === PlasmaCore.Types.Vertical) {
+                    return i18nc("@option:check completes sentence: New tasks appear", "On the top")
+                }
+                // horizontal
+                if (Application.layoutDirection === Qt.LeftToRight) {
+                    return i18nc("@option:check completes sentence: New tasks appear", "To the left");
+                } else {
+                    return i18nc("@option:check completes sentence: New tasks appear", "To the right");
+                }
+            }
+            QQC2.ButtonGroup.group: reverseModeRadioButtonGroup
+        }
+    }
+}
diff --git a/applets/taskmanager_compact/qml/ContextMenu.qml b/applets/taskmanager_compact/qml/ContextMenu.qml
new file mode 100644
index 0000000000..0b6ea0339e
--- /dev/null
+++ b/applets/taskmanager_compact/qml/ContextMenu.qml
@@ -0,0 +1,798 @@
+/*
+    SPDX-FileCopyrightText: 2012-2016 Eike Hein <hein@kde.org>
+    SPDX-FileCopyrightText: 2016 Kai Uwe Broulik <kde@privat.broulik.de>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+import QtQuick
+
+import org.kde.plasma.plasmoid
+
+import org.kde.plasma.core as PlasmaCore
+import org.kde.plasma.extras as PlasmaExtras
+
+import org.kde.taskmanager as TaskManager
+import org.kde.plasma.private.mpris as Mpris
+import plasma.applet.org.kde.plasma.taskmanager.compact as TaskManagerApplet
+
+PlasmaExtras.Menu {
+    id: menu
+
+    required property TaskManagerApplet.Backend backend
+    required property Mpris.Mpris2Model mpris2Source
+    required property /*QModelIndex*/var modelIndex
+
+    readonly property var atm: TaskManager.AbstractTasksModel
+
+    property bool showAllPlaces: false
+
+    placement: {
+        if (Plasmoid.location === PlasmaCore.Types.LeftEdge) {
+            return PlasmaExtras.Menu.RightPosedTopAlignedPopup;
+        } else if (Plasmoid.location === PlasmaCore.Types.TopEdge) {
+            return PlasmaExtras.Menu.BottomPosedLeftAlignedPopup;
+        } else if (Plasmoid.location === PlasmaCore.Types.RightEdge) {
+            return PlasmaExtras.Menu.LeftPosedTopAlignedPopup;
+        } else {
+            return PlasmaExtras.Menu.TopPosedLeftAlignedPopup;
+        }
+    }
+
+    minimumWidth: (visualParent as Item).width
+
+    onStatusChanged: {
+        if (visualParent && get(TaskManager.AbstractTasksModel.LauncherUrlWithoutIcon).toString() !== "" && status === PlasmaExtras.Menu.Open) {
+            activitiesDesktopsMenu.refresh();
+
+        } else if (status === PlasmaExtras.Menu.Closed) {
+            menu.destroy();
+        }
+    }
+
+    Component.onCompleted: {
+        // Cannot have "Connections" as child of PlasmaExtras.Menu.
+        backend.showAllPlaces.connect(showContextMenuWithAllPlaces);
+    }
+
+    Component.onDestruction: {
+        backend.showAllPlaces.disconnect(showContextMenuWithAllPlaces);
+    }
+
+    function showContextMenuWithAllPlaces(): void {
+        (visualParent as Task).showContextMenu({showAllPlaces: true});
+    }
+
+    function get(modelProp: int): var {
+        return tasksModel.data(modelIndex, modelProp)
+    }
+
+    function show(): void {
+        Plasmoid.contextualActionsAboutToShow();
+
+        loadDynamicLaunchActions(get(TaskManager.AbstractTasksModel.LauncherUrlWithoutIcon));
+        openRelative();
+    }
+
+    function newMenuItem(parent: QtObject): PlasmaExtras.MenuItem {
+        return Qt.createQmlObject(`
+            import org.kde.plasma.extras as PlasmaExtras
+
+            PlasmaExtras.MenuItem {}
+        `, parent) as PlasmaExtras.MenuItem;
+    }
+
+    function newSeparator(parent: QtObject): PlasmaExtras.MenuItem {
+        return Qt.createQmlObject(`
+            import org.kde.plasma.extras as PlasmaExtras
+
+            PlasmaExtras.MenuItem { separator: true }
+            `, parent) as PlasmaExtras.MenuItem;
+    }
+
+    function loadDynamicLaunchActions(launcherUrl: url): void {
+        let sections = [];
+
+        const placesActions = backend.placesActions(launcherUrl, showAllPlaces, menu);
+
+        if (placesActions.length > 0) {
+            sections.push({
+                title: i18nc("@title:group for section of menu items", "Places"),
+                group: "places",
+                actions: placesActions
+            });
+        } else {
+            sections.push({
+                title:  i18nc("@title:group for section of menu items", "Recent Files"),
+                group:   "recents",
+                actions: backend.recentDocumentActions(launcherUrl, menu)
+            });
+        }
+
+        // We always have actions category.
+        sections = sections.filter(section => section.actions.length > 0);
+
+        sections.push({
+            title: i18nc("@title:group for section of menu items", "Actions"),
+            group: "actions",
+            actions: backend.jumpListActions(launcherUrl, menu)
+        });
+
+        // C++ can override section heading by returning a QString as first action
+        sections.forEach((section) => {
+            if (typeof section.actions[0] === "string") {
+                section.title = section.actions.shift(); // take first
+            }
+        });
+
+        // QMenu does not limit its width automatically. Even if we set a maximumWidth
+        // it would just cut off text rather than eliding. So we do this manually.
+        const textMetrics = Qt.createQmlObject("import QtQuick; TextMetrics {}", menu);
+        textMetrics.elide = Qt.ElideRight;
+        textMetrics.elideWidth = TaskManagerApplet.LayoutMetrics.maximumContextMenuTextWidth();
+
+        sections.forEach(section => {
+            if (section["actions"].length > 0 || section["group"] === "actions") {
+                // Don't add the "Actions" header if the menu has nothing but actions
+                // in it, because then it's redundant (all menus have actions)
+                if (section.group !== "actions" || sections.length > 1) {
+                    var sectionHeader = newMenuItem(menu);
+                    sectionHeader.text = section["title"];
+                    sectionHeader.section = true;
+                    menu.addMenuItem(sectionHeader, startNewInstanceItem);
+                }
+            }
+
+            for (var i = 0; i < section["actions"].length; ++i) {
+                var item = newMenuItem(menu);
+                item.action = section["actions"][i];
+
+                textMetrics.text = item.action.text.replace("&", "&&");
+                item.action.text = textMetrics.elidedText;
+
+                menu.addMenuItem(item, startNewInstanceItem);
+            }
+        });
+
+        // Add Media Player control actions
+        const playerData = mpris2Source.playerForLauncherUrl(launcherUrl, get(TaskManager.AbstractTasksModel.AppPid));
+
+        if (playerData && playerData.canControl && !(get(TaskManager.AbstractTasksModel.WinIdList) !== undefined && get(TaskManager.AbstractTasksModel.WinIdList).length > 1)) {
+            const playing = playerData.playbackStatus === Mpris.PlaybackStatus.Playing;
+            let menuItem = menu.newMenuItem(menu);
+            menuItem.text = i18nc("Play previous track", "Previous Track");
+            menuItem.icon = "media-skip-backward";
+            menuItem.enabled = Qt.binding(() => {
+                return playerData.canGoPrevious;
+            });
+            menuItem.clicked.connect(() => {
+                playerData.Previous();
+            });
+            menu.addMenuItem(menuItem, startNewInstanceItem);
+
+            menuItem = menu.newMenuItem(menu);
+            // PlasmaCore Menu doesn't actually handle icons or labels changing at runtime...
+            menuItem.text = Qt.binding(() => {
+                // if CanPause, toggle the menu entry between Play & Pause, otherwise always use Play
+                return playing && playerData.canPause ? i18nc("Pause playback", "Pause") : i18nc("Start playback", "Play");
+            });
+            menuItem.icon = Qt.binding(() => {
+                return playing && playerData.canPause ? "media-playback-pause" : "media-playback-start";
+            });
+            menuItem.enabled = Qt.binding(() => {
+                return playing ? playerData.canPause : playerData.canPlay;
+            });
+            menuItem.clicked.connect(() => {
+                if (playing) {
+                    playerData.Pause();
+                } else {
+                    playerData.Play();
+                }
+            });
+            menu.addMenuItem(menuItem, startNewInstanceItem);
+
+            menuItem = menu.newMenuItem(menu);
+            menuItem.text = i18nc("Play next track", "Next Track");
+            menuItem.icon = "media-skip-forward";
+            menuItem.enabled = Qt.binding(() => {
+                return playerData.canGoNext;
+            });
+            menuItem.clicked.connect(() => {
+                playerData.Next();
+            });
+            menu.addMenuItem(menuItem, startNewInstanceItem);
+
+            menuItem = menu.newMenuItem(menu);
+            menuItem.text = i18nc("Stop playback", "Stop");
+            menuItem.icon = "media-playback-stop";
+            menuItem.enabled = Qt.binding(() => {
+                return playerData.canStop;
+            });
+            menuItem.clicked.connect(() => {
+                playerData.Stop();
+            });
+            menu.addMenuItem(menuItem, startNewInstanceItem);
+
+            // Technically media controls and audio streams are separate but for the user they're
+            // semantically related, don't add a separator in between.
+            if (!(menu.visualParent as Task).hasAudioStream) {
+                menu.addMenuItem(newSeparator(menu), startNewInstanceItem);
+            }
+
+            // If we don't have a window associated with the player but we can quit
+            // it through MPRIS we'll offer a "Quit" option instead of "Close"
+            if (!closeWindowItem.visible && playerData.canQuit) {
+                menuItem = menu.newMenuItem(menu);
+                menuItem.text = i18nc("Quit media player app", "Quit");
+                menuItem.icon = "application-exit";
+                menuItem.visible = Qt.binding(() => {
+                    return !closeWindowItem.visible;
+                });
+                menuItem.clicked.connect(() => {
+                    playerData.Quit();
+                });
+                menu.addMenuItem(menuItem);
+            }
+
+            // If we don't have a window associated with the player but we can raise
+            // it through MPRIS we'll offer a "Restore" option
+            if (get(TaskManager.AbstractTasksModel.IsLauncher) && !startNewInstanceItem.visible && playerData.canRaise) {
+                menuItem = menu.newMenuItem(menu);
+                menuItem.text = i18nc("Open or bring to the front window of media player app", "Restore");
+                menuItem.icon = playerData.iconName;
+                menuItem.visible = Qt.binding(() => {
+                    return !startNewInstanceItem.visible;
+                });
+                menuItem.clicked.connect(() => {
+                    playerData.Raise();
+                });
+                menu.addMenuItem(menuItem, startNewInstanceItem);
+            }
+        }
+
+        // We allow mute/unmute whenever an application has a stream, regardless of whether it
+        // is actually playing sound.
+        // This way you can unmute, e.g. a telephony app, even after the conversation has ended,
+        // so you still have it ringing later on.
+        if ((menu.visualParent as Task).hasAudioStream) {
+            const muteItem = menu.newMenuItem(menu);
+            muteItem.checkable = true;
+            muteItem.checked = Qt.binding(() => {
+                return menu.visualParent && menu.visualParent.muted;
+            });
+            muteItem.clicked.connect(() => {
+                menu.visualParent.toggleMuted();
+            });
+            muteItem.text = i18nc("@option:check inmenu, no separate unmute action", "Mute");
+            muteItem.icon = "audio-volume-muted" + (Application.layoutDirection === Qt.RightToLeft ? "-rtl" : "");
+            menu.addMenuItem(muteItem, startNewInstanceItem);
+
+            menu.addMenuItem(newSeparator(menu), startNewInstanceItem);
+        }
+    }
+
+    PlasmaExtras.MenuItem {
+        id: startNewInstanceItem
+        visible: menu.get(TaskManager.AbstractTasksModel.CanLaunchNewInstance)
+        text: i18nc("action:inmenu", "Open New Window")
+        icon: "window-new"
+
+        onClicked: tasksModel.requestNewInstance(menu.modelIndex)
+    }
+
+    PlasmaExtras.MenuItem {
+        id: virtualDesktopsMenuItem
+
+        visible: virtualDesktopInfo.numberOfDesktops > 1
+            && (menu.visualParent && !menu.get(TaskManager.AbstractTasksModel.IsLauncher)
+            && !menu.get(TaskManager.AbstractTasksModel.IsStartup)
+            && menu.get(TaskManager.AbstractTasksModel.IsVirtualDesktopsChangeable))
+
+        enabled: visible
+
+        text: i18nc("action:inmenu", "Move to &Desktop")
+        icon: "virtual-desktops"
+
+        readonly property Connections virtualDesktopsMenuConnections: Connections {
+            target: virtualDesktopInfo
+
+            function onNumberOfDesktopsChanged(): void {
+                Qt.callLater(virtualDesktopsMenu.refresh);
+            }
+            function onDesktopIdsChanged(): void {
+                Qt.callLater(virtualDesktopsMenu.refresh);
+            }
+            function onDesktopNamesChanged(): void {
+                Qt.callLater(virtualDesktopsMenu.refresh);
+            }
+        }
+
+        readonly property PlasmaExtras.Menu _virtualDesktopsMenu: PlasmaExtras.Menu {
+            id: virtualDesktopsMenu
+
+            visualParent: virtualDesktopsMenuItem.action
+
+            function refresh(): void {
+                clearMenuItems();
+
+                if (virtualDesktopInfo.numberOfDesktops <= 1 || !virtualDesktopsMenuItem.enabled) {
+                    return;
+                }
+
+                let menuItem = menu.newMenuItem(virtualDesktopsMenu);
+                menuItem.text = i18nc("action:inmenu", "Move &To Current Desktop");
+                menuItem.enabled = Qt.binding(() => {
+                    return menu.visualParent && menu.get(TaskManager.AbstractTasksModel.VirtualDesktops).indexOf(virtualDesktopInfo.currentDesktop) === -1;
+                });
+                menuItem.clicked.connect(() => {
+                    tasksModel.requestVirtualDesktops(menu.modelIndex, [virtualDesktopInfo.currentDesktop]);
+                });
+
+                menuItem = menu.newMenuItem(virtualDesktopsMenu);
+                menuItem.text = i18nc("action:inmenu", "&All Desktops");
+                menuItem.checkable = true;
+                menuItem.checked = Qt.binding(() => {
+                    return menu.visualParent && menu.get(TaskManager.AbstractTasksModel.IsOnAllVirtualDesktops);
+                });
+                menuItem.clicked.connect(() => {
+                    tasksModel.requestVirtualDesktops(menu.modelIndex, []);
+                });
+                menu.backend.setActionGroup(menuItem.action);
+
+                menu.newSeparator(virtualDesktopsMenu);
+
+                for (let i = 0; i < virtualDesktopInfo.desktopNames.length; ++i) {
+                    menuItem = menu.newMenuItem(virtualDesktopsMenu);
+                    menuItem.text = virtualDesktopInfo.desktopNames[i];
+                    menuItem.checkable = true;
+                    menuItem.checked = Qt.binding((i => {
+                        return () => menu.visualParent && menu.get(TaskManager.AbstractTasksModel.VirtualDesktops).indexOf(virtualDesktopInfo.desktopIds[i]) > -1;
+                    })(i));
+                    menuItem.clicked.connect((i => {
+                        return () => tasksModel.requestVirtualDesktops(menu.modelIndex, [virtualDesktopInfo.desktopIds[i]]);
+                    })(i));
+                    menu.backend.setActionGroup(menuItem.action);
+                }
+
+                menu.newSeparator(virtualDesktopsMenu);
+
+                menuItem = menu.newMenuItem(virtualDesktopsMenu);
+                menuItem.text = i18nc("action:inmenu", "&New Desktop");
+                menuItem.icon = "list-add";
+                menuItem.clicked.connect(() => {
+                    tasksModel.requestNewVirtualDesktop(menu.modelIndex);
+                });
+            }
+
+            Component.onCompleted: refresh()
+        }
+    }
+
+     PlasmaExtras.MenuItem {
+        id: activitiesDesktopsMenuItem
+
+        visible: activityInfo.numberOfRunningActivities > 1
+            && (menu.visualParent && !menu.get(TaskManager.AbstractTasksModel.IsLauncher)
+            && !menu.get(TaskManager.AbstractTasksModel.IsStartup))
+
+        enabled: visible
+
+        text: i18nc("action:inmenu", "Show in &Activities")
+        icon: "activities"
+
+        readonly property Connections activityInfoConnections: Connections {
+            target: activityInfo
+
+            function onNumberOfRunningActivitiesChanged(): void {
+                activitiesDesktopsMenu.refresh()
+            }
+        }
+
+        readonly property PlasmaExtras.Menu _activitiesDesktopsMenu: PlasmaExtras.Menu {
+            id: activitiesDesktopsMenu
+
+            visualParent: activitiesDesktopsMenuItem.action
+
+            function refresh(): void {
+                clearMenuItems();
+
+                if (activityInfo.numberOfRunningActivities <= 1) {
+                    return;
+                }
+
+                let menuItem = menu.newMenuItem(activitiesDesktopsMenu);
+                menuItem.text = i18nc("action:inmenu", "Add To Current Activity");
+                menuItem.enabled = Qt.binding(() => {
+                    return menu.visualParent && menu.get(TaskManager.AbstractTasksModel.Activities).length > 0 &&
+                           menu.get(TaskManager.AbstractTasksModel.Activities).indexOf(activityInfo.currentActivity) < 0;
+                });
+                menuItem.clicked.connect(() => {
+                    tasksModel.requestActivities(menu.modelIndex, menu.get(TaskManager.AbstractTasksModel.Activities).concat(activityInfo.currentActivity));
+                });
+
+                menuItem = menu.newMenuItem(activitiesDesktopsMenu);
+                menuItem.text = i18nc("action:inmenu", "All Activities");
+                menuItem.checkable = true;
+                menuItem.checked = Qt.binding(() => {
+                    return menu.visualParent && menu.get(TaskManager.AbstractTasksModel.Activities).length === 0;
+                });
+                menuItem.toggled.connect(checked => {
+                    let newActivities = []; // will cast to an empty QStringList i.e all activities
+                    if (!checked) {
+                        newActivities = [activityInfo.currentActivity];
+                    }
+                    tasksModel.requestActivities(menu.modelIndex, newActivities);
+                });
+
+                menu.newSeparator(activitiesDesktopsMenu);
+
+                const runningActivities = activityInfo.runningActivities();
+                for (let i = 0; i < runningActivities.length; ++i) {
+                    const activityId = runningActivities[i];
+
+                    menuItem = menu.newMenuItem(activitiesDesktopsMenu);
+                    menuItem.text = activityInfo.activityName(runningActivities[i]);
+                    menuItem.icon = activityInfo.activityIcon(runningActivities[i]);
+                    menuItem.checkable = true;
+                    menuItem.checked = Qt.binding((activityId => {
+                        return () => menu.visualParent && menu.get(TaskManager.AbstractTasksModel.Activities).indexOf(activityId) >= 0;
+                    })(activityId));
+                    menuItem.toggled.connect((activityId => {
+                        return checked => {
+                            let newActivities = menu.get(TaskManager.AbstractTasksModel.Activities);
+                            if (checked) {
+                                newActivities = newActivities.concat(activityId);
+                            } else {
+                                const index = newActivities.indexOf(activityId);
+                                if (index < 0) {
+                                    return;
+                                }
+
+                                newActivities.splice(index, 1);
+                            }
+                            return tasksModel.requestActivities(menu.modelIndex, newActivities);
+                        };
+                    })(activityId));
+                }
+
+                menu.newSeparator(activitiesDesktopsMenu);
+
+                for (let i = 0; i < runningActivities.length; ++i) {
+                    const activityId = runningActivities[i];
+                    const onActivities = menu.get(TaskManager.AbstractTasksModel.Activities);
+
+                    // if the task is on a single activity, don't insert a "move to" item for that activity
+                    if (onActivities.length === 1 && onActivities[0] === activityId) {
+                        continue;
+                    }
+
+                    menuItem = menu.newMenuItem(activitiesDesktopsMenu);
+                    menuItem.text = i18nc("action:inmenu", "Move to %1", activityInfo.activityName(activityId))
+                    menuItem.icon = activityInfo.activityIcon(activityId)
+                    menuItem.clicked.connect((activityId => {
+                        return () => tasksModel.requestActivities(menu.modelIndex, [activityId]);
+                    })(activityId));
+                }
+
+                menu.newSeparator(activitiesDesktopsMenu);
+            }
+
+            Component.onCompleted: refresh()
+        }
+    }
+
+    PlasmaExtras.MenuItem {
+        id: launcherToggleAction
+
+        visible: menu.visualParent
+            && !menu.get(TaskManager.AbstractTasksModel.IsLauncher)
+            && !menu.get(TaskManager.AbstractTasksModel.IsStartup)
+            && Plasmoid.immutability !== PlasmaCore.Types.SystemImmutable
+            && (activityInfo.numberOfRunningActivities < 2)
+            && !doesBelongToCurrentActivity()
+
+        enabled: menu.visualParent && menu.get(TaskManager.AbstractTasksModel.LauncherUrlWithoutIcon).toString() !== ""
+
+        text: i18nc("action:inmenu", "&Pin to Task Manager")
+        icon: "window-pin"
+
+        function doesBelongToCurrentActivity(): bool {
+            return tasksModel.launcherActivities(menu.get(TaskManager.AbstractTasksModel.LauncherUrlWithoutIcon))
+                .some(activity => activity === activityInfo.currentActivity || activity === activityInfo.nullUuid);
+        }
+
+        onClicked: {
+            tasksModel.requestAddLauncher(menu.get(TaskManager.AbstractTasksModel.LauncherUrl));
+        }
+    }
+
+    PlasmaExtras.MenuItem {
+        id: showLauncherInActivitiesItem
+
+        text: i18nc("action:inmenu", "&Pin to Task Manager")
+        icon: "window-pin"
+
+        visible: menu.visualParent
+            && !menu.get(TaskManager.AbstractTasksModel.IsStartup)
+            && Plasmoid.immutability !== PlasmaCore.Types.SystemImmutable
+            && (activityInfo.numberOfRunningActivities >= 2)
+
+        readonly property Connections activitiesLaunchersMenuConnections: Connections {
+            target: activityInfo
+
+            function onNumberOfRunningActivitiesChanged(): void {
+                activitiesDesktopsMenu.refresh()
+            }
+        }
+
+        readonly property PlasmaExtras.Menu _activitiesLaunchersMenu: PlasmaExtras.Menu {
+            id: activitiesLaunchersMenu
+            visualParent: showLauncherInActivitiesItem.action
+
+            function refresh(): void {
+                clearMenuItems();
+
+                if (menu.visualParent === null) return;
+
+                const createNewItem = (id, title, iconName, url, activities) => {
+                    var result = menu.newMenuItem(activitiesLaunchersMenu);
+                    result.text = title;
+                    result.icon = iconName;
+
+                    result.visible = true;
+                    result.checkable = true;
+
+                    result.checked = activities.some(activity => activity === id);
+
+                    result.clicked.connect(() => {
+                        if (result.checked) {
+                            tasksModel.requestAddLauncherToActivity(url, id);
+                        } else {
+                            tasksModel.requestRemoveLauncherFromActivity(url, id);
+                        }
+                    });
+
+                    return result;
+                };
+
+                if (menu.visualParent === null) return;
+
+                const url = menu.get(TaskManager.AbstractTasksModel.LauncherUrlWithoutIcon);
+
+                const activities = tasksModel.launcherActivities(url);
+
+                createNewItem(activityInfo.nullUuid, i18nc("action:inmenu", "On All Activities"), "", url, activities);
+
+                if (activityInfo.numberOfRunningActivities <= 1) {
+                    return;
+                }
+
+                createNewItem(activityInfo.currentActivity, i18nc("action:inmenu", "On The Current Activity"), activityInfo.activityIcon(activityInfo.currentActivity), url, activities);
+
+                menu.newSeparator(activitiesLaunchersMenu);
+
+                activityInfo.runningActivities()
+                    .forEach(id => {
+                        createNewItem(id, activityInfo.activityName(id), activityInfo.activityIcon(id), url, activities);
+                    });
+            }
+
+            Component.onCompleted: {
+                menu.visualParentChanged.connect(refresh);
+                refresh();
+            }
+        }
+    }
+
+    PlasmaExtras.MenuItem {
+        visible: (menu.visualParent
+                && menu.get(TaskManager.AbstractTasksModel.IsStartup) !== true
+                && Plasmoid.immutability !== PlasmaCore.Types.SystemImmutable
+                && !launcherToggleAction.visible
+                && activityInfo.numberOfRunningActivities < 2)
+
+        text: i18nc("action:inmenu", "Unpin from Task Manager")
+        icon: "window-unpin"
+
+        onClicked: {
+            tasksModel.requestRemoveLauncher(menu.get(TaskManager.AbstractTasksModel.LauncherUrlWithoutIcon));
+        }
+    }
+
+    PlasmaExtras.MenuItem {
+        id: moreActionsMenuItem
+
+        visible: (menu.visualParent && !menu.get(TaskManager.AbstractTasksModel.IsLauncher) && !menu.get(TaskManager.AbstractTasksModel.IsStartup))
+
+        enabled: visible
+
+        text: i18nc("item:inmenu opens submenu", "More")
+        icon: "view-more-symbolic"
+
+        readonly property PlasmaExtras.Menu moreMenu: PlasmaExtras.Menu {
+            visualParent: moreActionsMenuItem.action
+
+            PlasmaExtras.MenuItem {
+                enabled: menu.visualParent && menu.get(TaskManager.AbstractTasksModel.IsMovable)
+
+                text: i18nc("action:inmenu", "&Move")
+                icon: "transform-move"
+
+                onClicked: tasksModel.requestMove(menu.modelIndex)
+            }
+
+            PlasmaExtras.MenuItem {
+                enabled: menu.visualParent && menu.get(TaskManager.AbstractTasksModel.IsResizable)
+
+                text: i18nc("action:inmenu", "Re&size")
+                icon: "transform-scale"
+
+                onClicked: tasksModel.requestResize(menu.modelIndex)
+            }
+
+            PlasmaExtras.MenuItem {
+                visible: (menu.visualParent && !menu.get(TaskManager.AbstractTasksModel.IsLauncher) && !menu.get(TaskManager.AbstractTasksModel.IsStartup))
+
+                enabled: menu.visualParent && menu.get(TaskManager.AbstractTasksModel.IsMaximizable)
+
+                checkable: true
+                checked: menu.visualParent && menu.get(TaskManager.AbstractTasksModel.IsMaximized)
+
+                text: i18nc("action:inmenu", "Ma&ximize")
+                icon: "window-maximize"
+
+                onClicked: tasksModel.requestToggleMaximized(menu.modelIndex)
+            }
+
+            PlasmaExtras.MenuItem {
+                visible: (menu.visualParent && !menu.get(TaskManager.AbstractTasksModel.IsLauncher) && !menu.get(TaskManager.AbstractTasksModel.IsStartup))
+
+                enabled: menu.visualParent && menu.get(TaskManager.AbstractTasksModel.IsMinimizable)
+
+                checkable: true
+                checked: menu.visualParent && menu.get(TaskManager.AbstractTasksModel.IsMinimized)
+
+                text: i18nc("action:inmenu", "Mi&nimize")
+                icon: "window-minimize"
+
+                onClicked: tasksModel.requestToggleMinimized(menu.modelIndex)
+            }
+
+            PlasmaExtras.MenuItem {
+                checkable: true
+                checked: menu.visualParent && menu.get(TaskManager.AbstractTasksModel.IsKeepAbove)
+
+                text: i18nc("action:inmenu", "Keep &Above Others")
+                icon: "window-keep-above"
+
+                onClicked: tasksModel.requestToggleKeepAbove(menu.modelIndex)
+            }
+
+            PlasmaExtras.MenuItem {
+                checkable: true
+                checked: menu.visualParent && menu.get(TaskManager.AbstractTasksModel.IsKeepBelow)
+
+                text: i18nc("action:inmenu", "Keep &Below Others")
+                icon: "window-keep-below"
+
+                onClicked: tasksModel.requestToggleKeepBelow(menu.modelIndex)
+            }
+
+            PlasmaExtras.MenuItem {
+                enabled: menu.visualParent && menu.get(TaskManager.AbstractTasksModel.IsFullScreenable)
+
+                checkable: true
+                checked: menu.visualParent && menu.get(TaskManager.AbstractTasksModel.IsFullScreen)
+
+                text: i18nc("action:inmenu", "&Fullscreen")
+                icon: "view-fullscreen"
+
+                onClicked: tasksModel.requestToggleFullScreen(menu.modelIndex)
+            }
+
+            PlasmaExtras.MenuItem {
+                enabled: menu.visualParent && menu.get(TaskManager.AbstractTasksModel.IsShadeable)
+
+                checkable: true
+                checked: menu.visualParent && menu.get(TaskManager.AbstractTasksModel.IsShaded)
+                visible: Qt.platform.pluginName !== "wayland"
+
+                text: i18nc("action:inmenu", "&Shade")
+                icon: "window-shade"
+
+                onClicked: tasksModel.requestToggleShaded(menu.modelIndex)
+            }
+
+            PlasmaExtras.MenuItem {
+                enabled: menu.visualParent && menu.get(TaskManager.AbstractTasksModel.CanSetNoBoder)
+
+                checkable: true
+                checked: menu.visualParent && menu.get(TaskManager.AbstractTasksModel.HasNoBorder)
+
+                text: i18nc("@action:inmenu", "&No Titlebar and Frame")
+                icon: "edit-none-border"
+
+                onClicked: tasksModel.requestToggleNoBorder(menu.modelIndex)
+            }
+
+            PlasmaExtras.MenuItem {
+                enabled: menu.visualParent
+
+                checkable: true
+                checked: menu.visualParent && menu.get(TaskManager.AbstractTasksModel.IsExcludedFromCapture)
+                visible: Qt.platform.pluginName === "wayland"
+
+                text: i18nc("@action:inmenu", "&Hide from Screencast")
+                icon: "view-private"
+
+                onClicked: tasksModel.requestToggleExcludeFromCapture(menu.modelIndex)
+            }
+
+            PlasmaExtras.MenuItem {
+                separator: true
+            }
+
+            PlasmaExtras.MenuItem {
+                visible: (Plasmoid.configuration.groupingStrategy !== 0) && menu.get(TaskManager.AbstractTasksModel.IsWindow)
+
+                checkable: true
+                checked: menu.visualParent && menu.get(TaskManager.AbstractTasksModel.IsGroupable)
+
+                text: i18nc("@option:check inmenu", "Allow this program to be grouped")
+                icon: "view-group"
+
+                onClicked: tasksModel.requestToggleGrouping(menu.modelIndex)
+            }
+        }
+    }
+
+    PlasmaExtras.MenuItem { separator: true }
+
+    PlasmaExtras.MenuItem {
+        property PlasmaCore.Action configureAction: null
+
+        enabled: configureAction && configureAction.enabled
+        visible: configureAction && configureAction.visible
+
+        text: configureAction ? configureAction.text : ""
+        icon: configureAction ? configureAction.icon : ""
+
+        onClicked: configureAction.trigger()
+
+        Component.onCompleted: configureAction = Plasmoid.internalAction("configure")
+    }
+
+    PlasmaExtras.MenuItem {
+        property PlasmaCore.Action editModeAction: null
+
+        enabled: editModeAction && editModeAction.enabled
+        visible: editModeAction && editModeAction.visible
+
+        text: editModeAction ? editModeAction.text : ""
+        icon: editModeAction ? editModeAction.icon : ""
+
+        onClicked: editModeAction.trigger()
+
+        Component.onCompleted: editModeAction = Plasmoid.containment.internalAction("configure")
+    }
+
+    PlasmaExtras.MenuItem { separator: true }
+
+    PlasmaExtras.MenuItem {
+        id: closeWindowItem
+        visible: (menu.visualParent && !menu.get(TaskManager.AbstractTasksModel.IsLauncher) && !menu.get(TaskManager.AbstractTasksModel.IsStartup))
+
+        enabled: menu.visualParent && menu.get(TaskManager.AbstractTasksModel.IsClosable)
+
+        text: menu.get(TaskManager.AbstractTasksModel.IsGroupParent) ? i18nc("@action:inmenu", "&Close All") : i18nc("@action:inmenu", "&Close")
+        icon: "window-close"
+
+        onClicked: {
+            if (tasks.groupDialog !== null && tasks.groupDialog.visualParent === menu.visualParent) {
+                tasks.groupDialog.visible = false;
+            }
+
+            tasksModel.requestClose(menu.modelIndex);
+        }
+    }
+}
diff --git a/applets/taskmanager_compact/qml/GroupDialog.qml b/applets/taskmanager_compact/qml/GroupDialog.qml
new file mode 100644
index 0000000000..a2fbd334c2
--- /dev/null
+++ b/applets/taskmanager_compact/qml/GroupDialog.qml
@@ -0,0 +1,201 @@
+/*
+    SPDX-FileCopyrightText: 2012-2013 Eike Hein <hein@kde.org>
+    SPDX-FileCopyrightText: 2021 Fushan Wen <qydwhotmail@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+pragma ComponentBehavior: Bound
+
+import QtQuick
+import QtQml.Models
+
+import org.kde.plasma.core as PlasmaCore
+import org.kde.plasma.components as PlasmaComponents3
+import org.kde.kirigami as Kirigami
+import org.kde.plasma.plasmoid
+import plasma.applet.org.kde.plasma.taskmanager.compact as TaskManagerApplet
+
+PlasmaCore.PopupPlasmaWindow {
+    id: groupDialog
+
+    width: mouseHandler.implicitWidth + leftPadding + rightPadding
+    height: mouseHandler.implicitHeight + topPadding + bottomPadding
+
+    animated: true
+    removeBorderStrategy: Plasmoid.location === PlasmaCore.Types.Floating
+            ? PlasmaCore.AppletPopup.AtScreenEdges
+            : PlasmaCore.AppletPopup.AtScreenEdges | PlasmaCore.AppletPopup.AtPanelEdges
+
+    margin: (Plasmoid.containmentDisplayHints & PlasmaCore.Types.ContainmentPrefersFloatingApplets) ? Kirigami.Units.largeSpacing : 0
+    onActiveChanged: {
+        if (!active) {
+            visible = false;
+        }
+    }
+
+
+    popupDirection: switch (Plasmoid.location) {
+        case PlasmaCore.Types.TopEdge:
+            return Qt.BottomEdge
+        case PlasmaCore.Types.LeftEdge:
+            return Qt.RightEdge
+        case PlasmaCore.Types.RightEdge:
+            return Qt.LeftEdge
+        default:
+            return Qt.TopEdge
+    }
+
+    readonly property real preferredWidth: Screen.width / 3
+    readonly property real preferredHeight: Screen.height / 2
+    readonly property real contentWidth: mainItem.width // No padding here to avoid text elide.
+
+    property /*PlasmaCore.ItemStatus*/int _oldAppletStatus: PlasmaCore.Types.UnknownStatus
+
+    function findActiveTaskIndex(): void {
+        if (!tasksModel.activeTask) {
+            return;
+        }
+        for (let i = 0; i < groupListView.count; i++) {
+            if (tasksModel.makeModelIndex((visualParent as Task).index, i) === tasksModel.activeTask) {
+                groupListView.positionViewAtIndex(i, ListView.Contain); // Prevent visual glitches
+                groupListView.currentIndex = i;
+                return;
+            }
+        }
+    }
+
+    Component.onCompleted: {
+        // Don't bind visible at creation, otherwise it
+        // will be made visible before assigning the visual partent
+        // making the window flickering in the center of the screen before being moved
+        // in the correct position
+        visible = true
+    }
+
+    mainItem: MouseHandler {
+        id: mouseHandler
+        implicitWidth: Math.min(groupDialog.preferredWidth, Math.max(groupListView.maxWidth, groupDialog.visualParent.width))
+        implicitHeight: Math.min(groupDialog.preferredHeight, groupListView.maxHeight)
+
+        target: groupListView
+        handleWheelEvents: !scrollView.overflowing
+        isGroupDialog: true
+
+        Keys.onEscapePressed: event => {
+            groupDialog.visible = false;
+        }
+
+        function moveRow(event: KeyEvent, insertAt: int): void {
+            if (!(event.modifiers & Qt.ControlModifier) || !(event.modifiers & Qt.ShiftModifier)) {
+                event.accepted = false;
+                return;
+            } else if (insertAt < 0 || insertAt >= groupListView.count) {
+                return;
+            }
+
+            const parentModelIndex = tasksModel.makeModelIndex((groupDialog.visualParent as Task).index);
+            const status = tasksModel.move(groupListView.currentIndex, insertAt, parentModelIndex);
+            if (!status) {
+                return;
+            }
+
+            groupListView.currentIndex = insertAt;
+        }
+
+        PlasmaComponents3.ScrollView {
+            id: scrollView
+
+            // To achieve a bottom-to-top layout on vertical panels, the task manager
+            // is rotated by 180 degrees(see main.qml). This makes the group dialog's
+            // items rotated, so un-rotate them here to fix that.
+            rotation: Plasmoid.configuration.reverseMode && Plasmoid.formFactor === PlasmaCore.Types.Vertical ? 180 : 0
+
+            anchors.fill: parent
+            readonly property bool overflowing: leftPadding > 0 || rightPadding > 0 // Scrollbar is visible
+
+            ListView {
+                id: groupListView
+
+                readonly property real maxWidth: groupFilter.maxTextWidth
+                                                + TaskManagerApplet.LayoutMetrics.horizontalMargins()
+                                                + Kirigami.Units.iconSizes.medium
+                                                + 2 * (TaskManagerApplet.LayoutMetrics.labelMargin + TaskManagerApplet.LayoutMetrics.iconMargin)
+                                                + scrollView.leftPadding + scrollView.rightPadding
+                // Use groupFilter.count because sometimes count is not updated in time (BUG 446105)
+                readonly property real maxHeight: groupFilter.count * (TaskManagerApplet.LayoutMetrics.verticalMargins() + Math.max(Kirigami.Units.iconSizes.sizeForLabels, Kirigami.Units.iconSizes.medium))
+
+                model: DelegateModel {
+                    id: groupFilter
+
+                    readonly property TextMetrics textMetrics: TextMetrics {}
+                    property real maxTextWidth: 0
+
+                    model: tasksModel
+                    rootIndex: tasksModel.makeModelIndex((groupDialog.visualParent as Task).index)
+                    delegate: Task {
+                        id: delegate
+
+                        width: groupListView.width
+                        visible: true
+                        inPopup: true
+                        tasksRoot: tasks
+
+                        ListView.onRemove: Qt.callLater(groupFilter.updateMaxTextWidth)
+                        Connections {
+                            enabled: delegate.index < 20 // 20 is based on performance considerations.
+
+                            function onLabelTextChanged(): void { // ListView.onAdd included
+                                if (groupFilter.maxTextWidth === 0) {
+                                    // Update immediately to avoid shrinking
+                                    groupFilter.updateMaxTextWidth();
+                                } else {
+                                    Qt.callLater(groupFilter.updateMaxTextWidth);
+                                }
+                            }
+                        }
+                    }
+
+                    function updateMaxTextWidth(): void {
+                        let tempMaxTextWidth = 0;
+                        // 20 is based on performance considerations.
+                        for (let i = 0; i < Math.min(count, 20); i++) {
+                            textMetrics.text = items.get(i).model.display;
+                            if (textMetrics.boundingRect.width > tempMaxTextWidth) {
+                                tempMaxTextWidth = textMetrics.boundingRect.width;
+                            }
+                        }
+                        maxTextWidth = tempMaxTextWidth;
+                    }
+                }
+
+                reuseItems: false
+
+                Keys.onUpPressed: event => mouseHandler.moveRow(event, groupListView.currentIndex - 1)
+                Keys.onDownPressed: event => mouseHandler.moveRow(event, groupListView.currentIndex + 1)
+
+                onCountChanged: {
+                    if (count > 0) {
+                        tasks.cancelHighlightWindows()
+                    } else {
+                        groupDialog.visible = false;
+                    }
+                }
+            }
+        }
+    }
+
+    onVisibleChanged: {
+        if (visible) {
+            _oldAppletStatus = Plasmoid.status;
+            Plasmoid.status = PlasmaCore.Types.RequiresAttentionStatus;
+
+            groupDialog.requestActivate();
+            groupListView.forceActiveFocus(); // Active focus on ListView so keyboard navigation can work.
+            Qt.callLater(findActiveTaskIndex);
+        } else {
+            Plasmoid.status = _oldAppletStatus;
+            tasks.groupDialog = null;
+            destroy();
+        }
+    }
+}
diff --git a/applets/taskmanager_compact/qml/GroupExpanderOverlay.qml b/applets/taskmanager_compact/qml/GroupExpanderOverlay.qml
new file mode 100644
index 0000000000..c9b85cf02e
--- /dev/null
+++ b/applets/taskmanager_compact/qml/GroupExpanderOverlay.qml
@@ -0,0 +1,84 @@
+/*
+    SPDX-FileCopyrightText: 2012-2013 Eike Hein <hein@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+import QtQuick
+
+import org.kde.plasma.core as PlasmaCore
+import org.kde.ksvg as KSvg
+import org.kde.plasma.plasmoid
+
+KSvg.SvgItem {
+    id: arrow
+
+    anchors {
+        bottom: arrow.parent.bottom
+        horizontalCenter: iconBox.horizontalCenter
+    }
+
+    visible: parent.model.IsGroupParent
+
+    states: [
+        State {
+            name: "top"
+            when: Plasmoid.location === PlasmaCore.Types.TopEdge
+            AnchorChanges {
+                target: arrow
+                anchors.top: arrow.parent.top
+                anchors.left: undefined
+                anchors.right: undefined
+                anchors.bottom: undefined
+                anchors.horizontalCenter: iconBox.horizontalCenter
+                anchors.verticalCenter: undefined
+            }
+        },
+        State {
+            name: "left"
+            when: Plasmoid.location === PlasmaCore.Types.LeftEdge
+            AnchorChanges {
+                target: arrow
+                anchors.top: undefined
+                anchors.left: arrow.parent.left
+                anchors.right: undefined
+                anchors.bottom: undefined
+                anchors.horizontalCenter: undefined
+                anchors.verticalCenter: iconBox.verticalCenter
+            }
+        },
+        State {
+            name: "right"
+            when: Plasmoid.location === PlasmaCore.Types.RightEdge
+            AnchorChanges {
+                target: arrow
+                anchors.top: undefined
+                anchors.left: undefined
+                anchors.right: arrow.parent.right
+                anchors.bottom: undefined
+                anchors.horizontalCenter: undefined
+                anchors.verticalCenter: iconBox.verticalCenter
+            }
+        }
+    ]
+
+    implicitWidth: Math.min(naturalSize.width, iconBox.width)
+    implicitHeight: Math.min(naturalSize.height, iconBox.width)
+
+    imagePath: "widgets/tasks"
+    elementId: elementForLocation()
+
+    function elementForLocation(): string {
+        switch (Plasmoid.location) {
+        case PlasmaCore.Types.LeftEdge:
+            return "group-expander-left";
+        case PlasmaCore.Types.TopEdge:
+            return "group-expander-top";
+        case PlasmaCore.Types.RightEdge:
+            return "group-expander-right";
+        case PlasmaCore.Types.BottomEdge:
+        default:
+            return "group-expander-bottom";
+        }
+    }
+}
diff --git a/applets/taskmanager_compact/qml/MouseHandler.qml b/applets/taskmanager_compact/qml/MouseHandler.qml
new file mode 100644
index 0000000000..35f9e8d40b
--- /dev/null
+++ b/applets/taskmanager_compact/qml/MouseHandler.qml
@@ -0,0 +1,202 @@
+/*
+    SPDX-FileCopyrightText: 2012-2016 Eike Hein <hein@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+import QtQuick
+
+import org.kde.taskmanager as TaskManager
+import org.kde.plasma.plasmoid
+import plasma.applet.org.kde.plasma.taskmanager.compact as TaskManagerApplet
+
+DropArea {
+    id: dropArea
+    signal urlsDropped(var urls)
+
+    property Item target
+    property Item ignoredItem
+    property Item hoveredItem
+    property bool isGroupDialog: false
+    property bool moved: false
+
+    property alias handleWheelEvents: wheelHandler.handleWheelEvents
+
+    //ignore anything that is neither internal to TaskManager or a URL list
+    onEntered: event => {
+        if (event.formats.indexOf("text/x-plasmoidservicename") >= 0) {
+            event.accepted = false;
+        }
+        if (target.animating) { // Not all targets have an animating property
+            target.animating = false;
+        }
+    }
+
+    onPositionChanged: event => {
+        if (target.animating) {
+            return;
+        }
+
+        let above;
+        if (isGroupDialog) {
+            above = target.itemAt(event.x, event.y);
+        } else {
+            above = target.childAt(event.x, event.y);
+        }
+
+        if (!above) {
+            hoveredItem = null;
+            activationTimer.stop();
+
+            return;
+        }
+
+        // If we're mixing launcher tasks with other tasks and are moving
+        // a (small) launcher task across a non-launcher task, don't allow
+        // the latter to be the move target twice in a row for a while, as
+        // it will naturally be moved underneath the cursor as result of the
+        // initial move, due to being far larger than the launcher delegate.
+        // TODO: This restriction (minus the timer, which improves things)
+        // has been proven out in the EITM fork, but could be improved later
+        // by tracking the cursor movement vector and allowing the drag if
+        // the movement direction has reversed, establishing user intent to
+        // move back.
+        if (!Plasmoid.configuration.separateLaunchers
+                && tasks.dragSource?.model.IsLauncher
+                && !above.model.IsLauncher
+                && above === ignoredItem) {
+            return;
+        } else {
+            ignoredItem = null;
+        }
+
+        if (tasksModel.sortMode === TaskManager.TasksModel.SortManual && tasks.dragSource) {
+            // Reject drags between different TaskList instances.
+            if (tasks.dragSource.parent !== above.parent) {
+                return;
+            }
+
+            const insertAt = above.index;
+
+            if (tasks.dragSource !== above && tasks.dragSource.index !== insertAt) {
+                if (tasks.groupDialog) {
+                    tasksModel.move(tasks.dragSource.index, insertAt,
+                        tasksModel.makeModelIndex(tasks.groupDialog.visualParent.index));
+                } else {
+                    tasksModel.move(tasks.dragSource.index, insertAt);
+                }
+
+                ignoredItem = above;
+                ignoreItemTimer.restart();
+            }
+        } else if (!tasks.dragSource && hoveredItem !== above) {
+            hoveredItem = above;
+            activationTimer.restart();
+        }
+    }
+
+    onExited: {
+        hoveredItem = null;
+        activationTimer.stop();
+    }
+
+    onDropped: event => {
+        // Reject internal drops.
+        if (event.formats.indexOf("application/x-orgkdeplasmataskmanager_taskbuttonitem") >= 0) {
+            event.accepted = false;
+            return;
+        }
+
+        // Reject plasmoid drops.
+        if (event.formats.indexOf("text/x-plasmoidservicename") >= 0) {
+            event.accepted = false;
+            return;
+        }
+
+        if (event.hasUrls) {
+            urlsDropped(event.urls);
+            return;
+        }
+    }
+
+    Connections {
+        target: tasks
+
+        function onDragSourceChanged(): void {
+            if (!dragSource) {
+                dropArea.ignoredItem = null;
+                ignoreItemTimer.stop();
+            }
+        }
+    }
+
+    Timer {
+        id: ignoreItemTimer
+
+        repeat: false
+        interval: 750
+
+        onTriggered: {
+            dropArea.ignoredItem = null;
+        }
+    }
+
+    Timer {
+        id: activationTimer
+
+        interval: 250
+        repeat: false
+
+        onTriggered: {
+            if (parent.hoveredItem.model.IsGroupParent) {
+                TaskManagerApplet.TaskTools.createGroupDialog(parent.hoveredItem, tasks);
+            } else if (!parent.hoveredItem.model.IsLauncher) {
+                tasksModel.requestActivate(parent.hoveredItem.modelIndex());
+            }
+        }
+    }
+
+    WheelHandler {
+        id: wheelHandler
+
+        acceptedDevices: PointerDevice.Mouse | PointerDevice.TouchPad
+
+        property bool handleWheelEvents: true
+
+        enabled: handleWheelEvents && Plasmoid.configuration.wheelEnabled !== 0
+
+        onWheel: event => {
+            // magic number 15 for common "one scroll"
+            // See https://doc.qt.io/qt-6/qml-qtquick-wheelhandler.html#rotation-prop
+            let increment = 0;
+            while (rotation >= 15) {
+                rotation -= 15;
+                increment++;
+            }
+            while (rotation <= -15) {
+                rotation += 15;
+                increment--;
+            }
+            const anchor = dropArea.target.childAt(event.x, event.y);
+            if (Plasmoid.configuration.wheelEnabled === 3) {
+                const loudest = anchor?.audioStreams?.reduce((loudest, stream) => Math.max(loudest, stream.volume), 0)
+                const step = (pulseAudio.item.normalVolume - pulseAudio.item.minimalVolume) * pulseAudio.item.globalConfig.volumeStep / 100;
+                anchor?.audioStreams?.forEach((stream) => {
+                    let delta = step * increment;
+                    if (loudest > 0) {
+                        delta *= stream.volume / loudest;
+                    }
+                    const volume = stream.volume + delta;
+                    console.log(volume, Math.max(pulseAudio.item.minimalVolume, Math.min(volume, pulseAudio.item.normalVolume)));
+                    stream.model.Volume = Math.max(pulseAudio.item.minimalVolume, Math.min(volume, pulseAudio.item.normalVolume));
+                    stream.model.Muted = volume === 0
+                })
+            return;
+            }
+            while (increment !== 0) {
+                TaskManagerApplet.TaskTools.activateNextPrevTask(anchor, increment < 0, Plasmoid.configuration.wheelSkipMinimized, Plasmoid.configuration.wheelEnabled, tasks);
+                increment += (increment < 0) ? 1 : -1;
+            }
+        }
+    }
+}
diff --git a/applets/taskmanager_compact/qml/PipeWireThumbnail.qml b/applets/taskmanager_compact/qml/PipeWireThumbnail.qml
new file mode 100644
index 0000000000..9209ab581d
--- /dev/null
+++ b/applets/taskmanager_compact/qml/PipeWireThumbnail.qml
@@ -0,0 +1,23 @@
+/*
+    SPDX-FileCopyrightText: 2020 Aleix Pol Gonzalez <aleixpol@kde.org>
+
+    SPDX-License-Identifier: LGPL-2.0-or-later
+*/
+
+import QtQuick
+import org.kde.pipewire as PipeWire
+import org.kde.taskmanager as TaskManager
+
+PipeWire.PipeWireSourceItem {
+    id: pipeWireSourceItem
+
+    readonly property alias hasThumbnail: pipeWireSourceItem.ready
+
+    anchors.fill: parent
+    nodeId: waylandItem.nodeId
+
+    TaskManager.ScreencastingRequest {
+        id: waylandItem
+        uuid: thumbnailSourceItem.winId
+    }
+}
diff --git a/applets/taskmanager_compact/qml/PlayerController.qml b/applets/taskmanager_compact/qml/PlayerController.qml
new file mode 100644
index 0000000000..ebe029f36d
--- /dev/null
+++ b/applets/taskmanager_compact/qml/PlayerController.qml
@@ -0,0 +1,92 @@
+/*
+    SPDX-FileCopyrightText: 2013 Sebastian Kügler <sebas@kde.org>
+    SPDX-FileCopyrightText: 2014 Martin Gräßlin <mgraesslin@kde.org>
+    SPDX-FileCopyrightText: 2016 Kai Uwe Broulik <kde@privat.broulik.de>
+    SPDX-FileCopyrightText: 2017 Roman Gilg <subdiff@gmail.com>
+    SPDX-FileCopyrightText: 2020 Nate Graham <nate@kde.org>
+
+    SPDX-License-Identifier: LGPL-2.0-or-later
+*/
+
+pragma ComponentBehavior: Bound
+
+import QtQuick
+import QtQuick.Layouts
+
+import org.kde.plasma.components as PlasmaComponents3
+import org.kde.plasma.extras as PlasmaExtras
+import org.kde.kirigami as Kirigami
+import org.kde.plasma.private.mpris as Mpris
+
+RowLayout {
+    id: root
+
+    enabled: toolTipDelegate.playerData?.canControl ?? false
+    spacing: Kirigami.Units.smallSpacing
+
+    readonly property bool isPlaying: toolTipDelegate.playerData?.playbackStatus === Mpris.PlaybackStatus.Playing
+
+    ColumnLayout {
+        Layout.fillWidth: true
+        spacing: 0
+
+        ScrollableTextWrapper {
+            id: songTextWrapper
+
+            Layout.fillWidth: true
+            Layout.preferredHeight: songText.height
+            implicitWidth: songText.implicitWidth
+
+            textItem: PlasmaComponents3.Label {
+                id: songText
+                maximumLineCount: artistText.visible ? 1 : 2
+                wrapMode: Text.NoWrap
+                elide: parent.state ? Text.ElideNone : Text.ElideRight
+                text: toolTipDelegate.playerData?.track ?? ""
+                textFormat: Text.PlainText
+            }
+        }
+
+        ScrollableTextWrapper {
+            id: artistTextWrapper
+
+            Layout.fillWidth: true
+            Layout.preferredHeight: artistText.height
+            implicitWidth: artistText.implicitWidth
+            visible: artistText.text.length > 0
+
+            textItem: PlasmaExtras.DescriptiveLabel {
+                id: artistText
+                wrapMode: Text.NoWrap
+                elide: parent.state ? Text.ElideNone : Text.ElideRight
+                text: toolTipDelegate.playerData?.artist ?? ""
+                font: Kirigami.Theme.smallFont
+                textFormat: Text.PlainText
+            }
+        }
+    }
+
+    PlasmaComponents3.ToolButton {
+        enabled: toolTipDelegate.playerData?.canGoPrevious ?? false
+        icon.name: mirrored ? "media-skip-forward" : "media-skip-backward"
+        onClicked: toolTipDelegate.playerData.Previous()
+    }
+
+    PlasmaComponents3.ToolButton {
+        enabled: (root.isPlaying ? toolTipDelegate.playerData?.canPause : toolTipDelegate.playerData?.canPlay) ?? false
+        icon.name: root.isPlaying ? "media-playback-pause" : "media-playback-start"
+        onClicked: {
+            if (!root.isPlaying) {
+                toolTipDelegate.playerData.Play();
+            } else {
+                toolTipDelegate.playerData.Pause();
+            }
+        }
+    }
+
+    PlasmaComponents3.ToolButton {
+        enabled: toolTipDelegate.playerData?.canGoNext ?? false
+        icon.name: mirrored ? "media-skip-backward" : "media-skip-forward"
+        onClicked: toolTipDelegate.playerData.Next()
+    }
+}
diff --git a/applets/taskmanager_compact/qml/PulseAudio.qml b/applets/taskmanager_compact/qml/PulseAudio.qml
new file mode 100644
index 0000000000..bbafcd8d0f
--- /dev/null
+++ b/applets/taskmanager_compact/qml/PulseAudio.qml
@@ -0,0 +1,121 @@
+/*
+    SPDX-FileCopyrightText: 2017 Kai Uwe Broulik <kde@privat.broulik.de>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+pragma ComponentBehavior: Bound
+
+import QtQuick
+
+import org.kde.plasma.private.volume as PlasmaPa
+
+QtObject {
+    id: pulseAudio
+
+    signal streamsChanged()
+
+    readonly property /*PlasmaPa.GlobalConfig*/ QtObject globalConfig: PlasmaPa.GlobalConfig { }
+
+    // It's a JS object so we can do key lookup and don't need to take care of filtering duplicates.
+    property var pidMatches: new Set()
+
+    // TODO Evict cache at some point, preferably if all instances of an application closed.
+    function registerPidMatch(appName: string) {
+        if (!hasPidMatch(appName)) {
+            pidMatches.add(appName);
+
+            // In case this match is new, notify that streams might have changed.
+            // This way we also catch the case when the non-playing instance
+            // shows up first.
+            // Only notify if we changed to avoid infinite recursion.
+            streamsChanged();
+        }
+    }
+
+    function hasPidMatch(appName: string): bool {
+        return pidMatches.has(appName);
+    }
+
+    function findStreams(key: string, value: var): /*[QtObject]*/ var {
+        return findStreamsFn(stream => stream[key] === value);
+    }
+
+    function findStreamsFn(fn: var): var {
+        const streams = [];
+        for (let i = 0, count = instantiator.count; i < count; ++i) {
+            const stream = instantiator.objectAt(i);
+            if (fn(stream)) {
+                streams.push(stream);
+            }
+        }
+        return streams;
+    }
+
+    function streamsForAppId(appId: string): /*[QtObject]*/ var {
+        return findStreams("portalAppId", appId);
+    }
+
+    function streamsForAppName(appName: string): /*[QtObject]*/ var {
+        return findStreams("appName", appName);
+    }
+
+    function streamsForPid(pid: int): /*[QtObject]*/ var {
+        // skip stream that has portalAppId
+        // app using portal may have a sandbox pid
+        const streams = findStreamsFn(stream => stream.pid === pid && !stream.portalAppId);
+
+        if (streams.length === 0) {
+            for (let i = 0, length = instantiator.count; i < length; ++i) {
+                const stream = instantiator.objectAt(i) as StreamDelegate;
+
+                if (stream.parentPid === -1) {
+                    stream.parentPid = backend.parentPid(stream.pid);
+                }
+
+                if (stream.parentPid === pid) {
+                    streams.push(stream);
+                }
+            }
+        }
+
+        return streams;
+    }
+
+    // QtObject has no default property, hence adding the Instantiator to one explicitly.
+    readonly property Instantiator instantiator: Instantiator {
+        model: PlasmaPa.PulseObjectFilterModel {
+            filters: [ { role: "VirtualStream", value: false } ]
+            sourceModel: PlasmaPa.SinkInputModel {}
+        }
+
+        component StreamDelegate: QtObject {
+            id: delegate
+            required property var model
+            readonly property int pid: model.Client?.properties["application.process.id"] ?? 0
+            // Determined on demand.
+            property int parentPid: -1
+            readonly property string appName: model.Client?.properties["application.name"] ?? ""
+            readonly property string portalAppId: model.Client?.properties["pipewire.access.portal.app_id"] ?? ""
+            readonly property bool muted: model.Muted
+            // whether there is nothing actually going on on that stream
+            readonly property bool corked: model.Corked
+            readonly property int volume: model.Volume
+
+            function mute(): void {
+                model.Muted = true;
+            }
+            function unmute(): void {
+                model.Muted = false;
+            }
+        }
+
+        delegate: StreamDelegate { }
+
+        onObjectAdded: (index, object) => pulseAudio.streamsChanged()
+        onObjectRemoved: (index, object) => pulseAudio.streamsChanged()
+    }
+
+    readonly property int minimalVolume: PlasmaPa.PulseAudio.MinimalVolume
+    readonly property int normalVolume: PlasmaPa.PulseAudio.NormalVolume
+}
diff --git a/applets/taskmanager_compact/qml/ScrollableTextWrapper.qml b/applets/taskmanager_compact/qml/ScrollableTextWrapper.qml
new file mode 100644
index 0000000000..85283535d3
--- /dev/null
+++ b/applets/taskmanager_compact/qml/ScrollableTextWrapper.qml
@@ -0,0 +1,65 @@
+/*
+    SPDX-FileCopyrightText: 2020 Tranter Madi <trmdi@yandex.com>
+
+    SPDX-License-Identifier: LGPL-2.0-or-later
+*/
+
+pragma ComponentBehavior: Bound
+
+import QtQuick
+
+MouseArea {
+    id: root
+
+    required property Text textItem
+
+    onTextItemChanged: {
+        textItem.parent = this;
+        textItem.width = Qt.binding(() => width);
+    }
+
+    clip: textItem.elide === Text.ElideNone
+    hoverEnabled: true
+
+    onContainsMouseChanged: {
+        if (!containsMouse) {
+            state = "";
+        }
+    }
+
+    Timer {
+        id: timer
+        interval: 500
+        running: root.containsMouse
+        onTriggered: {
+            if (root.width < root.textItem.implicitWidth) {
+                root.state = "ShowRight";
+            }
+        }
+    }
+
+    states: [
+        State {
+            name: ""
+            PropertyChanges {
+                root.textItem.x: 0
+            }
+        },
+        State {
+            name: "ShowRight"
+            PropertyChanges {
+                root.textItem.x: root.width - root.textItem.implicitWidth
+            }
+        }
+    ]
+
+    transitions: Transition {
+        to: "ShowRight"
+        NumberAnimation {
+            target: root.textItem
+            properties: "x"
+            easing.type: Easing.Linear
+            duration: Math.abs(root.textItem.implicitWidth - root.width) * 25
+        }
+    }
+}
diff --git a/applets/taskmanager_compact/qml/Task.qml b/applets/taskmanager_compact/qml/Task.qml
new file mode 100644
index 0000000000..736e077a27
--- /dev/null
+++ b/applets/taskmanager_compact/qml/Task.qml
@@ -0,0 +1,693 @@
+/*
+    SPDX-FileCopyrightText: 2012-2013 Eike Hein <hein@kde.org>
+    SPDX-FileCopyrightText: 2024 Nate Graham <nate@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+pragma ComponentBehavior: Bound
+
+import QtQuick
+import QtQuick.Layouts
+
+import org.kde.plasma.core as PlasmaCore
+import org.kde.ksvg as KSvg
+import org.kde.plasma.extras as PlasmaExtras
+import org.kde.plasma.components as PlasmaComponents3
+import org.kde.kirigami as Kirigami
+import plasma.applet.org.kde.plasma.taskmanager.compact as TaskManagerApplet
+import org.kde.plasma.plasmoid
+
+PlasmaCore.ToolTipArea {
+    id: task
+
+    activeFocusOnTab: true
+
+    // To achieve a bottom-to-top layout on vertical panels, the task manager
+    // is rotated by 180 degrees(see main.qml). This makes the tasks rotated,
+    // so un-rotate them here to fix that.
+    rotation: Plasmoid.configuration.reverseMode && Plasmoid.formFactor === PlasmaCore.Types.Vertical ? 180 : 0
+
+    implicitHeight: inPopup
+                    ? TaskManagerApplet.LayoutMetrics.preferredHeightInPopup()
+                    : (tasksRoot.vertical
+                        ? TaskManagerApplet.LayoutMetrics.preferredMinHeight()
+                        : Math.max(tasksRoot.height / Plasmoid.configuration.maxStripes,
+                             TaskManagerApplet.LayoutMetrics.preferredMinHeight()))
+    implicitWidth: tasksRoot.vertical
+        ? Math.max(TaskManagerApplet.LayoutMetrics.preferredMinWidth(), Math.min(TaskManagerApplet.LayoutMetrics.preferredMaxWidth(), tasksRoot.width / Plasmoid.configuration.maxStripes))
+        : 0
+
+    Layout.fillWidth: true
+    Layout.fillHeight: !inPopup
+    Layout.maximumWidth: tasksRoot.vertical
+        ? -1
+        : ((model.IsLauncher && !tasksRoot.iconsOnly) ? tasksRoot.height / taskList.rows : (TaskManagerApplet.LayoutMetrics.preferredMaxWidth() * 0.4))
+    Layout.maximumHeight: tasksRoot.vertical ? TaskManagerApplet.LayoutMetrics.preferredMaxHeight() : -1
+
+    required property var model
+    required property int index
+    required property /*main.qml*/ Item tasksRoot
+
+    readonly property int pid: model.AppPid
+    readonly property string appName: model.AppName
+    readonly property string appId: model.AppId.replace(/\.desktop/, '')
+    readonly property bool isIcon: tasksRoot.iconsOnly || model.IsLauncher
+    property bool toolTipOpen: false
+    property bool inPopup: false
+    property bool isWindow: model.IsWindow
+    property int childCount: model.ChildCount
+    property int previousChildCount: 0
+    property alias labelText: label.text
+    property QtObject contextMenu: null
+    readonly property bool smartLauncherEnabled: !inPopup
+    property QtObject smartLauncherItem: null
+
+    property Item audioStreamIcon: null
+    property var audioStreams: []
+    property bool delayAudioStreamIndicator: false
+    property bool completed: false
+    readonly property bool audioIndicatorsEnabled: Plasmoid.configuration.indicateAudioStreams
+    readonly property bool tooltipControlsEnabled: Plasmoid.configuration.tooltipControls
+    readonly property bool hasAudioStream: audioStreams.length > 0
+    readonly property bool playingAudio: hasAudioStream && audioStreams.some(item => !item.corked)
+    readonly property bool muted: hasAudioStream && audioStreams.every(item => item.muted)
+
+    readonly property bool highlighted: (inPopup && activeFocus) || (!inPopup && containsMouse)
+        || (task.contextMenu && task.contextMenu.status === PlasmaExtras.Menu.Open)
+        || (!!tasksRoot.groupDialog && tasksRoot.groupDialog.visualParent === task)
+
+    active: !inPopup && !tasksRoot.groupDialog && task.contextMenu?.status !== PlasmaExtras.Menu.Open
+    interactive: model.IsWindow || mainItem.playerData
+    location: Plasmoid.location
+    mainItem: !Plasmoid.configuration.showToolTips || !model.IsWindow ? pinnedAppToolTipDelegate : openWindowToolTipDelegate
+
+    onXChanged: {
+        if (!completed) {
+            return;
+        }
+        if (oldX < 0) {
+            oldX = x;
+            return;
+        }
+        moveAnim.x = oldX - x + translateTransform.x;
+        moveAnim.y = translateTransform.y;
+        oldX = x;
+        moveAnim.restart();
+    }
+    onYChanged: {
+        if (!completed) {
+            return;
+        }
+        if (oldY < 0) {
+            oldY = y;
+            return;
+        }
+        moveAnim.y = oldY - y + translateTransform.y;
+        moveAnim.x = translateTransform.x;
+        oldY = y;
+        moveAnim.restart();
+    }
+
+    property real oldX: -1
+    property real oldY: -1
+    SequentialAnimation {
+        id: moveAnim
+        property real x
+        property real y
+        onRunningChanged: {
+            if (running) {
+                ++task.parent.animationsRunning;
+            } else {
+                --task.parent.animationsRunning;
+            }
+        }
+        ParallelAnimation {
+            NumberAnimation {
+                target: translateTransform
+                properties: "x"
+                from: moveAnim.x
+                to: 0
+                easing.type: Easing.OutQuad
+                duration: Kirigami.Units.longDuration
+            }
+            NumberAnimation {
+                target: translateTransform
+                properties: "y"
+                from: moveAnim.y
+                to: 0
+                easing.type: Easing.OutQuad
+                duration: Kirigami.Units.longDuration
+            }
+        }
+    }
+    transform: Translate {
+        id: translateTransform
+    }
+
+    Accessible.name: model.display
+    Accessible.description: {
+        if (!model.display) {
+            return "";
+        }
+
+        if (model.IsLauncher) {
+            return i18nc("@info:usagetip %1 application name", "Launch %1", model.display)
+        }
+
+        let smartLauncherDescription = "";
+        if (iconBox.active) {
+            smartLauncherDescription += i18ncp("@info:tooltip", "There is %1 new message.", "There are %1 new messages.", task.smartLauncherItem.count);
+        }
+
+        if (model.IsGroupParent) {
+            switch (Plasmoid.configuration.groupedTaskVisualization) {
+            case 0:
+                break; // Use the default description
+            case 1: {
+                return `${i18nc("@info:usagetip %1 task name", "Show Task tooltip for %1", model.display)}; ${smartLauncherDescription}`;
+            }
+            case 2: {
+                if (effectWatcher.registered) {
+                    return `${i18nc("@info:usagetip %1 task name", "Show windows side by side for %1", model.display)}; ${smartLauncherDescription}`;
+                }
+                // fallthrough
+            }
+            default:
+                return `${i18nc("@info:usagetip %1 task name", "Open textual list of windows for %1", model.display)}; ${smartLauncherDescription}`;
+            }
+        }
+
+        return `${i18nc("@info:usagetip %1 task name", "Activate %1", model.display)}; ${smartLauncherDescription}`;
+    }
+    Accessible.role: Accessible.Button
+    Accessible.onPressAction: leftTapHandler.leftClick()
+
+    onToolTipVisibleChanged: toolTipVisible => {
+        task.toolTipOpen = toolTipVisible;
+        if (!toolTipVisible) {
+            tasksRoot.toolTipOpenedByClick = null;
+        } else {
+            tasksRoot.toolTipAreaItem = task;
+        }
+    }
+
+    onContainsMouseChanged: {
+        if (containsMouse) {
+            task.forceActiveFocus(Qt.MouseFocusReason);
+            task.updateMainItemBindings();
+        } else {
+            tasksRoot.toolTipOpenedByClick = null;
+        }
+    }
+
+    onHighlightedChanged: {
+        // ensure it doesn't get stuck with a window highlighted
+        tasksRoot.cancelHighlightWindows();
+    }
+
+    onPidChanged: updateAudioStreams({delay: false})
+    onAppNameChanged: updateAudioStreams({delay: false})
+
+    onIsWindowChanged: {
+        if (model.IsWindow) {
+            taskInitComponent.createObject(task);
+            updateAudioStreams({delay: false});
+        }
+    }
+
+    onChildCountChanged: {
+        if (TaskManagerApplet.TaskTools.taskManagerInstanceCount < 2 && childCount > previousChildCount) {
+            tasksModel.requestPublishDelegateGeometry(modelIndex(), backend.globalRect(task), task);
+        }
+
+        previousChildCount = childCount;
+    }
+
+    onIndexChanged: {
+        hideToolTip();
+
+        if (!inPopup && !tasksRoot.vertical
+                && !Plasmoid.configuration.separateLaunchers) {
+            tasksRoot.requestLayout();
+        }
+    }
+
+    onSmartLauncherEnabledChanged: {
+        if (smartLauncherEnabled && !smartLauncherItem) {
+            const component = Qt.createComponent("plasma.applet.org.kde.plasma.taskmanager", "SmartLauncherItem");
+            const smartLauncher = component.createObject(task);
+            component.destroy();
+
+            smartLauncher.launcherUrl = Qt.binding(() => model.LauncherUrlWithoutIcon);
+
+            smartLauncherItem = smartLauncher;
+        }
+    }
+
+    onHasAudioStreamChanged: {
+        const audioStreamIconActive = hasAudioStream && audioIndicatorsEnabled;
+        if (!audioStreamIconActive) {
+            if (audioStreamIcon !== null) {
+                audioStreamIcon.destroy();
+                audioStreamIcon = null;
+            }
+            return;
+        }
+        // Create item on demand instead of using Loader to reduce memory consumption,
+        // because only a few applications have audio streams.
+        const component = Qt.createComponent("AudioStream.qml");
+        audioStreamIcon = component.createObject(task);
+        component.destroy();
+    }
+    onAudioIndicatorsEnabledChanged: task.hasAudioStreamChanged()
+
+    Keys.onMenuPressed: event => contextMenuTimer.start()
+    Keys.onReturnPressed: event => TaskManagerApplet.TaskTools.activateTask(modelIndex(), model, event.modifiers, task, Plasmoid, tasksRoot, effectWatcher.registered)
+    Keys.onEnterPressed: event => Keys.returnPressed(event);
+    Keys.onSpacePressed: event => Keys.returnPressed(event);
+    Keys.onUpPressed: event => Keys.leftPressed(event)
+    Keys.onDownPressed: event => Keys.rightPressed(event)
+    Keys.onLeftPressed: event => {
+        if (!inPopup && (event.modifiers & Qt.ControlModifier) && (event.modifiers & Qt.ShiftModifier)) {
+            tasksModel.move(task.index, task.index - 1);
+        } else {
+            event.accepted = false;
+        }
+    }
+    Keys.onRightPressed: event => {
+        if (!inPopup && (event.modifiers & Qt.ControlModifier) && (event.modifiers & Qt.ShiftModifier)) {
+            tasksModel.move(task.index, task.index + 1);
+        } else {
+            event.accepted = false;
+        }
+    }
+
+    function modelIndex(): /*QModelIndex*/ var {
+        return inPopup
+            ? tasksModel.makeModelIndex(groupDialog.visualParent.index, index)
+            : tasksModel.makeModelIndex(index);
+    }
+
+    function showContextMenu(args: var): void {
+        task.hideImmediately();
+        contextMenu = tasksRoot.createContextMenu(task, modelIndex(), args) as ContextMenu;
+        contextMenu.show();
+    }
+
+    function updateAudioStreams(args: var): void {
+        if (args) {
+            // When the task just appeared (e.g. virtual desktop switch), show the audio indicator
+            // right away. Only when audio streams change during the lifetime of this task, delay
+            // showing that to avoid distraction.
+            delayAudioStreamIndicator = !!args.delay;
+        }
+
+        var pa = pulseAudio.item;
+        if (!pa || !task.isWindow) {
+            task.audioStreams = [];
+            return;
+        }
+
+        // Check appid first for app using portal
+        // https://docs.pipewire.org/page_portal.html
+        var streams = pa.streamsForAppId(task.appId);
+        if (!streams.length) {
+            streams = pa.streamsForPid(model.AppPid);
+            if (streams.length) {
+                pa.registerPidMatch(model.AppName);
+            } else {
+                // We only want to fall back to appName matching if we never managed to map
+                // a PID to an audio stream window. Otherwise if you have two instances of
+                // an application, one playing and the other not, it will look up appName
+                // for the non-playing instance and erroneously show an indicator on both.
+                if (!pa.hasPidMatch(model.AppName)) {
+                    streams = pa.streamsForAppName(model.AppName);
+                }
+            }
+        }
+
+        task.audioStreams = streams;
+    }
+
+    function toggleMuted(): void {
+        if (muted) {
+            task.audioStreams.forEach(item => item.unmute());
+        } else {
+            task.audioStreams.forEach(item => item.mute());
+        }
+    }
+
+    // Will also be called in activateTaskAtIndex(index)
+    function updateMainItemBindings(): void {
+        if ((mainItem.parentTask === this && mainItem.rootIndex.row === index)
+            || (tasksRoot.toolTipOpenedByClick === null && !active)
+            || (tasksRoot.toolTipOpenedByClick !== null && tasksRoot.toolTipOpenedByClick !== this)) {
+            return;
+        }
+
+        mainItem.blockingUpdates = (mainItem.isGroup !== model.IsGroupParent); // BUG 464597 Force unload the previous component
+
+        mainItem.parentTask = this;
+        mainItem.rootIndex = tasksModel.makeModelIndex(index, -1);
+
+        mainItem.appName = Qt.binding(() => model.AppName);
+        mainItem.pidParent = Qt.binding(() => model.AppPid);
+        mainItem.windows = Qt.binding(() => model.WinIdList);
+        mainItem.isGroup = Qt.binding(() => model.IsGroupParent);
+        mainItem.icon = Qt.binding(() => model.decoration);
+        mainItem.launcherUrl = Qt.binding(() => model.LauncherUrlWithoutIcon);
+        mainItem.isLauncher = Qt.binding(() => model.IsLauncher);
+        mainItem.isMinimized = Qt.binding(() => model.IsMinimized);
+        mainItem.display = Qt.binding(() => model.display);
+        mainItem.genericName = Qt.binding(() => model.GenericName);
+        mainItem.virtualDesktops = Qt.binding(() => model.VirtualDesktops);
+        mainItem.isOnAllVirtualDesktops = Qt.binding(() => model.IsOnAllVirtualDesktops);
+        mainItem.activities = Qt.binding(() => model.Activities);
+
+        mainItem.smartLauncherCountVisible = Qt.binding(() => smartLauncherItem?.countVisible ?? false);
+        mainItem.smartLauncherCount = Qt.binding(() => mainItem.smartLauncherCountVisible ? (smartLauncherItem?.count ?? 0) : 0);
+
+        mainItem.blockingUpdates = false;
+        tasksRoot.toolTipAreaItem = this;
+    }
+
+    Connections {
+        target: pulseAudio.item
+        ignoreUnknownSignals: true // Plasma-PA might not be available
+        function onStreamsChanged(): void {
+            task.updateAudioStreams({delay: true})
+        }
+    }
+
+    TapHandler {
+        id: menuTapHandler
+        acceptedButtons: Qt.LeftButton
+        acceptedDevices: PointerDevice.TouchScreen | PointerDevice.Stylus
+        gesturePolicy: TapHandler.ReleaseWithinBounds
+        onLongPressed: {
+            // When we're a launcher, there's no window controls, so we can show all
+            // places without the menu getting super huge.
+            if (task.model.IsLauncher) {
+                task.showContextMenu({showAllPlaces: true})
+            } else {
+                task.showContextMenu();
+            }
+        }
+    }
+
+    TapHandler {
+        acceptedButtons: Qt.RightButton
+        acceptedDevices: PointerDevice.Mouse | PointerDevice.TouchPad | PointerDevice.Stylus
+        gesturePolicy: TapHandler.WithinBounds // Release grab when menu appears
+        onPressedChanged: if (pressed) contextMenuTimer.start()
+    }
+
+    Timer {
+        id: contextMenuTimer
+        interval: 0
+        onTriggered: menuTapHandler.longPressed()
+    }
+
+    TapHandler {
+        id: leftTapHandler
+        acceptedButtons: Qt.LeftButton
+        onTapped: (eventPoint, button) => leftClick()
+
+        function leftClick(): void {
+            if (task.active) {
+                task.hideToolTip();
+            }
+            TaskManagerApplet.TaskTools.activateTask(modelIndex(), model, point.modifiers, task, Plasmoid, tasksRoot, effectWatcher.registered);
+        }
+    }
+
+    TapHandler {
+        acceptedButtons: Qt.MiddleButton | Qt.BackButton | Qt.ForwardButton
+        onTapped: (eventPoint, button) => {
+            if (button === Qt.MiddleButton) {
+                if (Plasmoid.configuration.middleClickAction === TaskManagerApplet.Backend.NewInstance) {
+                    tasksModel.requestNewInstance(modelIndex());
+                } else if (Plasmoid.configuration.middleClickAction === TaskManagerApplet.Backend.Close) {
+                    tasksModel.requestClose(modelIndex());
+                } else if (Plasmoid.configuration.middleClickAction === TaskManagerApplet.Backend.ToggleMinimized) {
+                    tasksModel.requestToggleMinimized(modelIndex());
+                } else if (Plasmoid.configuration.middleClickAction === TaskManagerApplet.Backend.ToggleGrouping) {
+                    tasksModel.requestToggleGrouping(modelIndex());
+                } else if (Plasmoid.configuration.middleClickAction === TaskManagerApplet.Backend.BringToCurrentDesktop) {
+                    tasksModel.requestVirtualDesktops(modelIndex(), [virtualDesktopInfo.currentDesktop]);
+                }
+            } else if (button === Qt.BackButton || button === Qt.ForwardButton) {
+                const playerData = mpris2Source.playerForLauncherUrl(task.model.LauncherUrlWithoutIcon, task.model.AppPid);
+                if (playerData) {
+                    if (button === Qt.BackButton) {
+                        playerData.Previous();
+                    } else {
+                        playerData.Next();
+                    }
+                } else {
+                    eventPoint.accepted = false;
+                }
+            }
+
+            task.tasksRoot.cancelHighlightWindows();
+        }
+    }
+
+    KSvg.FrameSvgItem {
+        id: frame
+
+        anchors {
+            fill: parent
+
+            topMargin: (!task.tasksRoot.vertical && taskList.rows > 1) ? TaskManagerApplet.LayoutMetrics.iconMargin : 0
+            bottomMargin: (!task.tasksRoot.vertical && taskList.rows > 1) ? TaskManagerApplet.LayoutMetrics.iconMargin : 0
+            leftMargin: ((task.inPopup || task.tasksRoot.vertical) && taskList.columns > 1) ? TaskManagerApplet.LayoutMetrics.iconMargin : 0
+            rightMargin: ((task.inPopup || task.tasksRoot.vertical) && taskList.columns > 1) ? TaskManagerApplet.LayoutMetrics.iconMargin : 0
+        }
+
+        imagePath: "widgets/tasks"
+        property bool isHovered: task.highlighted && Plasmoid.configuration.taskHoverEffect
+        property string basePrefix: "normal"
+        prefix: isHovered ? TaskManagerApplet.TaskTools.taskPrefixHovered(basePrefix, Plasmoid.location) : TaskManagerApplet.TaskTools.taskPrefix(basePrefix, Plasmoid.location)
+
+        // Avoid repositioning delegate item after dragFinished
+        DragHandler {
+            id: dragHandler
+            grabPermissions: PointerHandler.CanTakeOverFromHandlersOfDifferentType
+
+            function setRequestedInhibitDnd(value: bool): void {
+                // This is modifying the value in the panel containment that
+                // inhibits accepting drag and drop, so that we don't accidentally
+                // drop the task on this panel.
+                let item = this;
+                while (item.parent) {
+                    item = item.parent;
+                    if (item.appletRequestsInhibitDnD !== undefined) {
+                        item.appletRequestsInhibitDnD = value
+                    }
+                }
+            }
+
+            onActiveChanged: {
+                if (active) {
+                    icon.grabToImage(result => {
+                        if (!dragHandler.active) {
+                            // BUG 466675 grabToImage is async, so avoid updating dragSource when active is false
+                            return;
+                        }
+                        setRequestedInhibitDnd(true);
+                        tasksRoot.dragSource = task;
+                        dragHelper.Drag.imageSource = result.url;
+                        dragHelper.Drag.mimeData = {
+                            "text/x-orgkdeplasmataskmanager_taskurl": backend.tryDecodeApplicationsUrl(model.LauncherUrlWithoutIcon).toString(),
+                            [model.MimeType]: model.MimeData,
+                            "application/x-orgkdeplasmataskmanager_taskbuttonitem": model.MimeData,
+                        };
+                        dragHelper.Drag.active = dragHandler.active;
+                    });
+                } else {
+                    setRequestedInhibitDnd(false);
+                    dragHelper.Drag.active = false;
+                    dragHelper.Drag.imageSource = "";
+                }
+            }
+        }
+    }
+
+    Loader {
+        id: taskProgressOverlayLoader
+
+        anchors.fill: frame
+        asynchronous: true
+        active: task.smartLauncherItem && task.smartLauncherItem.progressVisible
+
+        source: "TaskProgressOverlay.qml"
+    }
+
+    Loader {
+        id: iconBox
+
+        anchors {
+            left: parent.left
+            leftMargin: adjustMargin(true, parent.width, taskFrame.margins.left)
+            top: parent.top
+            topMargin: adjustMargin(false, parent.height, taskFrame.margins.top)
+        }
+
+        width: task.inPopup ? Math.max(Kirigami.Units.iconSizes.sizeForLabels, Kirigami.Units.iconSizes.medium) : Math.min(task.parent?.minimumWidth ?? 0, task.height)
+        height: task.inPopup ? width : (parent.height - adjustMargin(false, parent.height, taskFrame.margins.top)
+                 - adjustMargin(false, parent.height, taskFrame.margins.bottom))
+
+        asynchronous: true
+        active: height >= Kirigami.Units.iconSizes.small
+                && task.smartLauncherItem && task.smartLauncherItem.countVisible
+        source: "TaskBadgeOverlay.qml"
+
+        function adjustMargin(isVertical: bool, size: real, margin: real): real {
+            if (!size) {
+                return margin;
+            }
+
+            var margins = isVertical ? TaskManagerApplet.LayoutMetrics.horizontalMargins() : TaskManagerApplet.LayoutMetrics.verticalMargins();
+
+            if ((size - margins) < Kirigami.Units.iconSizes.small) {
+                return Math.ceil((margin * (Kirigami.Units.iconSizes.small / size)) / 2);
+            }
+
+            return margin;
+        }
+
+        Kirigami.Icon {
+            id: icon
+
+            anchors.fill: parent
+
+            active: task.highlighted
+            enabled: true
+
+            source: task.model.decoration
+        }
+
+        states: [
+            // Using a state transition avoids a binding loop between label.visible and
+            // the text label margin, which derives from the icon width.
+            State {
+                name: "standalone"
+                when: !label.visible && task.parent
+
+                AnchorChanges {
+                    target: iconBox
+                    anchors.left: undefined
+                    anchors.horizontalCenter: parent.horizontalCenter
+                }
+
+                PropertyChanges {
+                    iconBox.anchors.leftMargin: 0
+                    iconBox.width: Math.min(task.parent.minimumWidth, tasksRoot.height)
+                        - iconBox.adjustMargin(true, task.width, taskFrame.margins.left)
+                        - iconBox.adjustMargin(true, task.width, taskFrame.margins.right)
+                }
+            }
+        ]
+
+        Loader {
+            anchors.centerIn: parent
+            width: Math.min(parent.width, parent.height)
+            height: width
+            active: task.model.IsStartup
+            sourceComponent: busyIndicator
+        }
+    }
+
+    PlasmaComponents3.Label {
+        id: label
+
+        visible: (task.inPopup || !task.tasksRoot.iconsOnly && !task.model.IsLauncher
+            && (parent.width - iconBox.height - Kirigami.Units.smallSpacing) >= TaskManagerApplet.LayoutMetrics.spaceRequiredToShowText())
+
+        anchors {
+            fill: parent
+            leftMargin: taskFrame.margins.left + iconBox.width + TaskManagerApplet.LayoutMetrics.labelMargin
+            topMargin: taskFrame.margins.top
+            rightMargin: taskFrame.margins.right + (task.audioStreamIcon !== null && task.audioStreamIcon.visible ? (task.audioStreamIcon.width + TaskManagerApplet.LayoutMetrics.labelMargin) : 0)
+            bottomMargin: taskFrame.margins.bottom
+        }
+
+        wrapMode: (maximumLineCount === 1) ? Text.NoWrap : Text.Wrap
+        elide: Text.ElideRight
+        textFormat: Text.PlainText
+        verticalAlignment: Text.AlignVCenter
+        maximumLineCount: Plasmoid.configuration.maxTextLines || undefined
+
+        // The accessible item of this element is only used for debugging
+        // purposes, and it will never gain focus (thus it won't interfere
+        // with screenreaders).
+        Accessible.ignored: !visible
+        Accessible.name: parent.Accessible.name + "-labelhint"
+
+        // use State to avoid unnecessary re-evaluation when the label is invisible
+        states: State {
+            name: "labelVisible"
+            when: label.visible
+
+            PropertyChanges {
+                label.text: task.model.display
+            }
+        }
+    }
+
+    states: [
+        State {
+            name: "launcher"
+            when: task.model.IsLauncher
+
+            PropertyChanges {
+                frame.basePrefix: ""
+            }
+        },
+        State {
+            name: "attention"
+            when: task.model.IsDemandingAttention || (task.smartLauncherItem && task.smartLauncherItem.urgent)
+
+            PropertyChanges {
+                frame.basePrefix: "attention"
+            }
+        },
+        State {
+            name: "minimized"
+            when: task.model.IsMinimized
+
+            PropertyChanges {
+                frame.basePrefix: "minimized"
+            }
+        },
+        State {
+            name: "active"
+            when: task.model.IsActive
+
+            PropertyChanges {
+                frame.basePrefix: "focus"
+            }
+        }
+    ]
+
+    Component.onCompleted: {
+        if (!inPopup && model.IsWindow) {
+            const component = Qt.createComponent("GroupExpanderOverlay.qml");
+            component.createObject(task);
+            component.destroy();
+            updateAudioStreams({delay: false});
+        }
+
+        if (!inPopup && !model.IsWindow) {
+            taskInitComponent.createObject(task);
+        }
+        completed = true;
+    }
+    Component.onDestruction: {
+        if (moveAnim.running) {
+            (task.parent as TaskList).animationsRunning -= 1;
+        }
+    }
+}
diff --git a/applets/taskmanager_compact/qml/TaskBadgeOverlay.qml b/applets/taskmanager_compact/qml/TaskBadgeOverlay.qml
new file mode 100644
index 0000000000..bb04fb8631
--- /dev/null
+++ b/applets/taskmanager_compact/qml/TaskBadgeOverlay.qml
@@ -0,0 +1,86 @@
+/*
+    SPDX-FileCopyrightText: 2016 Kai Uwe Broulik <kde@privat.broulik.de>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+import QtQuick
+import org.kde.kirigami as Kirigami
+import org.kde.graphicaleffects as KGraphicalEffects
+import org.kde.plasma.plasmoid
+
+Item {
+    id: root
+
+    readonly property int iconWidthDelta: (icon.width - icon.paintedWidth) / 2
+    readonly property bool shiftBadgeDown: (Plasmoid.pluginName === "org.kde.plasma.icontasks") && task.audioStreamIcon !== null
+
+    Item {
+        id: badgeMask
+        anchors.fill: parent
+
+        Rectangle {
+            readonly property int offset: Math.round(Math.max(Kirigami.Units.smallSpacing / 2, badgeMask.width / 32))
+
+            anchors.right: parent.right
+            anchors.rightMargin: -offset
+            y: root.shiftBadgeDown ? (icon.height / 2) : 0
+
+            Behavior on y {
+                NumberAnimation { duration: Kirigami.Units.longDuration }
+            }
+
+            visible: task.smartLauncherItem.countVisible
+            width: badgeRect.width + offset * 2
+            height: badgeRect.height + offset * 2
+            radius: badgeRect.radius + offset * 2
+
+            // Badge changes width based on number.
+            onWidthChanged: maskShaderSource.scheduleUpdate()
+            onVisibleChanged: maskShaderSource.scheduleUpdate()
+            onYChanged: maskShaderSource.scheduleUpdate()
+        }
+    }
+
+    ShaderEffectSource {
+        id: iconShaderSource
+        sourceItem: icon
+        hideSource: GraphicsInfo.api !== GraphicsInfo.Software
+    }
+
+    ShaderEffectSource {
+        id: maskShaderSource
+        sourceItem: badgeMask
+        hideSource: true
+        live: false
+    }
+
+    KGraphicalEffects.BadgeEffect {
+        id: shader
+
+        anchors.fill: parent
+        source: iconShaderSource
+        mask: maskShaderSource
+
+        onWidthChanged: maskShaderSource.scheduleUpdate()
+        onHeightChanged: maskShaderSource.scheduleUpdate()
+    }
+
+    Badge {
+        id: badgeRect
+
+        anchors.right: parent.right
+        y: {
+            const offset = Math.round(Math.max(Kirigami.Units.smallSpacing / 2, badgeMask.width / 32));
+            return offset + (root.shiftBadgeDown ? (icon.height / 2) : 0);
+        }
+
+        Behavior on y {
+            NumberAnimation { duration: Kirigami.Units.longDuration }
+        }
+
+        height: Math.round(icon.paintedHeight * 0.45)
+        visible: task.smartLauncherItem.countVisible
+        number: task.smartLauncherItem.count
+    }
+}
diff --git a/applets/taskmanager_compact/qml/TaskList.qml b/applets/taskmanager_compact/qml/TaskList.qml
new file mode 100644
index 0000000000..c399272e21
--- /dev/null
+++ b/applets/taskmanager_compact/qml/TaskList.qml
@@ -0,0 +1,62 @@
+/*
+    SPDX-FileCopyrightText: 2012-2013 Eike Hein <hein@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+import QtQuick
+import QtQuick.Layouts
+
+import org.kde.plasma.plasmoid
+import org.kde.plasma.core as PlasmaCore
+import plasma.applet.org.kde.plasma.taskmanager.compact as TaskManagerApplet
+
+GridLayout {
+    property bool animating: false
+
+    rowSpacing: 0
+    columnSpacing: 0
+
+    property int animationsRunning: 0
+    onAnimationsRunningChanged: {
+        animating = animationsRunning > 0;
+    }
+
+    required property int count
+
+    readonly property bool vertical: Plasmoid.formFactor === PlasmaCore.Types.Vertical
+
+    readonly property real minimumWidth: children
+        .filter(item => item.visible && item.width > 0)
+        .reduce((minimumWidth, item) => Math.min(minimumWidth, item.width), Infinity)
+
+    readonly property int stripeCount: {
+        if (Plasmoid.configuration.maxStripes === 1) {
+            return 1;
+        }
+
+        // The maximum number of stripes allowed by the applet's size
+        const stripeSizeLimit = vertical
+            ? Math.floor(parent.width / children[0].implicitWidth)
+            : Math.floor(parent.height / children[0].implicitHeight)
+        const maxStripes = Math.min(Plasmoid.configuration.maxStripes, stripeSizeLimit)
+
+        if (Plasmoid.configuration.forceStripes) {
+            return maxStripes;
+        }
+
+        // The number of tasks that will fill a "stripe" before starting the next one
+        const maxTasksPerStripe = vertical
+            ? Math.ceil(parent.height / TaskManagerApplet.LayoutMetrics.preferredMinHeight())
+            : Math.ceil(parent.width / TaskManagerApplet.LayoutMetrics.preferredMinWidth())
+
+        return Math.min(Math.ceil(count / maxTasksPerStripe), maxStripes)
+    }
+
+    readonly property int orthogonalCount: {
+        return Math.ceil(count / stripeCount);
+    }
+
+    rows: vertical ? orthogonalCount : stripeCount
+    columns: vertical ? stripeCount : orthogonalCount
+}
diff --git a/applets/taskmanager_compact/qml/TaskProgressOverlay.qml b/applets/taskmanager_compact/qml/TaskProgressOverlay.qml
new file mode 100644
index 0000000000..0e7b022e3f
--- /dev/null
+++ b/applets/taskmanager_compact/qml/TaskProgressOverlay.qml
@@ -0,0 +1,49 @@
+/*
+    SPDX-FileCopyrightText: 2016 Kai Uwe Broulik <kde@privat.broulik.de>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+import QtQuick
+import QtQuick.Templates as T
+
+import org.kde.ksvg as KSvg
+import org.kde.plasma.plasmoid
+
+import plasma.applet.org.kde.plasma.taskmanager.compact as TaskManagerApplet
+
+T.ProgressBar {
+    id: control
+
+    implicitWidth: Math.max(implicitBackgroundWidth + leftInset + rightInset,
+                            implicitContentWidth + leftPadding + rightPadding)
+    implicitHeight: Math.max(implicitBackgroundHeight + topInset + bottomInset,
+                             implicitContentHeight + topPadding + bottomPadding)
+
+    hoverEnabled: false
+    padding: 0
+
+    from: 0
+    to: 100
+    value: task.smartLauncherItem.progress
+
+    contentItem: Item {
+        LayoutMirroring.enabled: Application.layoutDirection === Qt.RightToLeft
+        LayoutMirroring.childrenInherit: false
+
+        clip: true
+
+        KSvg.FrameSvgItem {
+            id: progressFrame
+
+            anchors.left: parent.left
+            width: parent.width * control.position
+            height: parent.height
+
+            imagePath: "widgets/tasks"
+            prefix: TaskManagerApplet.TaskTools.taskPrefix("progress", Plasmoid.location).concat(TaskManagerApplet.TaskTools.taskPrefix("hover", Plasmoid.location))
+        }
+    }
+
+    background: null
+}
diff --git a/applets/taskmanager_compact/qml/ToolTipDelegate.qml b/applets/taskmanager_compact/qml/ToolTipDelegate.qml
new file mode 100644
index 0000000000..05cb5e2d6d
--- /dev/null
+++ b/applets/taskmanager_compact/qml/ToolTipDelegate.qml
@@ -0,0 +1,174 @@
+/*
+    SPDX-FileCopyrightText: 2013 Sebastian Kügler <sebas@kde.org>
+    SPDX-FileCopyrightText: 2014 Martin Gräßlin <mgraesslin@kde.org>
+    SPDX-FileCopyrightText: 2016 Kai Uwe Broulik <kde@privat.broulik.de>
+    SPDX-FileCopyrightText: 2017 Roman Gilg <subdiff@gmail.com>
+    SPDX-FileCopyrightText: 2024 Nate Graham <nate@kde.org>
+
+    SPDX-License-Identifier: LGPL-2.0-or-later
+*/
+
+pragma ComponentBehavior: Bound
+
+import QtQml.Models
+import QtQuick
+
+import org.kde.plasma.core as PlasmaCore
+import org.kde.plasma.components as PlasmaComponents3
+import org.kde.plasma.private.mpris as Mpris
+import org.kde.kirigami as Kirigami
+
+import org.kde.plasma.plasmoid
+
+Loader {
+    id: toolTipDelegate
+
+    property Task parentTask
+    property /*QModelIndex*/var rootIndex
+
+    property string appName
+    property int pidParent
+    property bool isGroup
+
+    property /*list<WId> where WId = int|string*/ var windows: []
+    readonly property bool isWin: windows.length > 0
+
+    property /*QIcon*/ var icon
+    property url launcherUrl
+    property bool isLauncher
+    property bool isMinimized
+
+    // Needed for generateSubtext()
+    property string display
+    property string genericName
+    property /*list<var>*/ var virtualDesktops: [] // Can't use list<var> because of QTBUG-127600
+    property bool isOnAllVirtualDesktops
+    property list<string> activities: []
+
+    property bool smartLauncherCountVisible
+    property int smartLauncherCount
+
+    property bool blockingUpdates: false
+
+    readonly property bool isVerticalPanel: Plasmoid.formFactor === PlasmaCore.Types.Vertical
+    // This number controls the overall size of the window tooltips
+    readonly property int tooltipInstanceMaximumWidth: Kirigami.Units.gridUnit * 16
+
+    // These properties are required to make tooltip interactive when there is a player but no window is present.
+    readonly property Mpris.PlayerContainer playerData: mpris2Source.playerForLauncherUrl(launcherUrl, pidParent)
+
+    LayoutMirroring.enabled: Application.layoutDirection === Qt.RightToLeft
+    LayoutMirroring.childrenInherit: true
+
+    active: !blockingUpdates && rootIndex !== undefined && ((parentTask && parentTask.containsMouse) || Window.visibility !== Window.Hidden)
+    asynchronous: true
+
+    sourceComponent: isGroup ? groupToolTip : singleTooltip
+
+    Component {
+        id: singleTooltip
+
+        ToolTipInstance {
+            index: 0 // TODO: maybe set to -1, because that's what the component checks against?
+            submodelIndex: toolTipDelegate.rootIndex
+            appPid: toolTipDelegate.pidParent
+            display: toolTipDelegate.display
+            isMinimized: toolTipDelegate.isMinimized
+            isOnAllVirtualDesktops: toolTipDelegate.isOnAllVirtualDesktops
+            virtualDesktops: toolTipDelegate.virtualDesktops
+            activities: toolTipDelegate.activities
+            model: null
+        }
+    }
+
+    Component {
+        id: groupToolTip
+
+        PlasmaComponents3.ScrollView {
+            // 2 * Kirigami.Units.smallSpacing is for the margin of tooltipDialog
+            readonly property real maximumWidth: Screen.desktopAvailableWidth - 2 * Kirigami.Units.smallSpacing
+            readonly property real maximumHeight: Screen.desktopAvailableWidth - 2 * Kirigami.Units.smallSpacing
+
+            implicitWidth: {
+                // when vertical, all delegates have the same fixed width, but with an extra
+                // gridUnit when thumbnails are disabled to match the default tooltip margins
+                let listContentWidth = groupToolTipListView.orientation == ListView.Vertical
+                   ? toolTipDelegate.tooltipInstanceMaximumWidth + (toolTipDelegate.isWin && Plasmoid.configuration.showToolTips ? 0 : Kirigami.Units.gridUnit)
+                   : groupToolTipListView.contentWidth
+
+                return leftPadding + rightPadding + Math.min(maximumWidth, Math.max(delegateModel.estimatedWidth, listContentWidth))
+            }
+
+            implicitHeight: {
+                // not using bottomPadding; in PC3 it's either 0 or the scrollbar height, and here
+                // this causes binding loops when turning it off - manually computing the width
+                // avoids this.
+                let scrollBarRequired = groupToolTipListView.contentWidth > maximumWidth
+                let scrollBarHeight = scrollBarRequired ? PlasmaComponents3.ScrollBar.horizontal.height : 0
+                // currentItem is never unloaded, so we use it for sizing. Default to the same value
+                // that estimatedHeight while it's not available
+                let listContentHeight = groupToolTipListView.orientation == ListView.Vertical
+                    ? groupToolTipListView.contentHeight
+                    : groupToolTipListView.currentItem?.implicitHeight ?? toolTipDelegate.tooltipInstanceMaximumWidth
+
+                return Math.min(maximumHeight, Math.max(delegateModel.estimatedHeight, listContentHeight + scrollBarHeight))
+            }
+
+            ListView {
+                id: groupToolTipListView
+
+                model: delegateModel
+
+                orientation: toolTipDelegate.isVerticalPanel || !Plasmoid.configuration.showToolTips ? ListView.Vertical : ListView.Horizontal
+                reuseItems: true
+
+                // Lots of spacing with no thumbnails looks bad
+                spacing: Plasmoid.configuration.showToolTips ? Kirigami.Units.gridUnit : 0
+
+                // Required to know whether to display the media player buttons on the first window or not
+                property bool hasTrackInATitle: {
+                    var found = false
+                    for (var i=0; i<model.items.count && !found; i++) {
+                        found = model.items.get(i).model.display.includes(toolTipDelegate.playerData?.track)
+                    }
+                    return found
+                }
+
+                Component.onCompleted: if (parentTask.model.IsActive) {
+                    groupToolTipListView.positionViewAtIndex(tasksModel.activeTask.row, ListView.Center)
+                }
+            }
+
+            DelegateModel {
+                id: delegateModel
+
+                // On Wayland, a tooltip has a significant resizing process, so estimate the size first.
+                readonly property real estimatedWidth: (toolTipDelegate.isVerticalPanel || !Plasmoid.configuration.showToolTips ? 1 : count) * (toolTipDelegate.tooltipInstanceMaximumWidth + Kirigami.Units.gridUnit) - Kirigami.Units.gridUnit
+                readonly property real estimatedHeight: (toolTipDelegate.isVerticalPanel || !Plasmoid.configuration.showToolTips ? count : 1) * (Plasmoid.configuration.showToolTips ? (toolTipDelegate.tooltipInstanceMaximumWidth / 2 + Kirigami.Units.gridUnit) : Kirigami.Units.gridUnit * 2) - Kirigami.Units.gridUnit
+
+                model: tasksModel
+
+                rootIndex: toolTipDelegate.rootIndex
+                onRootIndexChanged: {
+                    if (parentTask.model.IsActive) {
+                            groupToolTipListView.positionViewAtIndex(tasksModel.activeTask.row, ListView.Center)
+                    } else {
+                        groupToolTipListView.positionViewAtBeginning() // Fix a visual glitch (when the mouse moves from a tooltip with a moved scrollbar to another tooltip without a scrollbar)
+                    }
+                }
+
+                delegate: ToolTipInstance {
+                    submodelIndex: tasksModel.makeModelIndex(toolTipDelegate.rootIndex.row, index)
+                    appPid: model.AppPid
+                    // 'display' is required already
+                    isMinimized: model.IsMinimized
+                    isOnAllVirtualDesktops: model.IsOnAllVirtualDesktops
+                    virtualDesktops: model.VirtualDesktops
+                    activities: model.Activities
+                    hasTrackInATitle: groupToolTipListView.hasTrackInATitle
+                    orientation: groupToolTipListView.orientation
+                }
+            }
+        }
+    }
+}
diff --git a/applets/taskmanager_compact/qml/ToolTipInstance.qml b/applets/taskmanager_compact/qml/ToolTipInstance.qml
new file mode 100644
index 0000000000..9fd2759143
--- /dev/null
+++ b/applets/taskmanager_compact/qml/ToolTipInstance.qml
@@ -0,0 +1,543 @@
+/*
+    SPDX-FileCopyrightText: 2013 Sebastian Kügler <sebas@kde.org>
+    SPDX-FileCopyrightText: 2014 Martin Gräßlin <mgraesslin@kde.org>
+    SPDX-FileCopyrightText: 2016 Kai Uwe Broulik <kde@privat.broulik.de>
+    SPDX-FileCopyrightText: 2017 Roman Gilg <subdiff@gmail.com>
+    SPDX-FileCopyrightText: 2020-2024 Nate Graham <nate@kde.org>
+
+    SPDX-License-Identifier: LGPL-2.0-or-later
+*/
+
+pragma ComponentBehavior: Bound
+
+import QtQuick
+import QtQuick.Layouts
+import Qt5Compat.GraphicalEffects as GE
+
+import org.kde.plasma.plasmoid
+import org.kde.plasma.core as PlasmaCore
+import org.kde.plasma.components as PlasmaComponents3
+import org.kde.plasma.extras as PlasmaExtras
+import org.kde.kirigami as Kirigami
+import org.kde.kwindowsystem
+
+ColumnLayout {
+    id: root
+
+    required property var model
+    required property int index
+    required property /*QModelIndex*/ var submodelIndex
+    required property int appPid
+    required property string display
+    required property bool isMinimized
+    required property bool isOnAllVirtualDesktops
+    required property /*list<var>*/ var virtualDesktops // Can't use list<var> because of QTBUG-127600
+    required property list<string> activities
+
+    property bool hasTrackInATitle: false
+    property int orientation: ListView.Vertical // vertical for compact single-window tooltips
+
+    // HACK: Avoid blank space in the tooltip after closing a window
+    ListView.onPooled: width = height = 0
+    ListView.onReused: width = height = undefined
+
+    readonly property string title: {
+        if (!toolTipDelegate.isWin) {
+            return toolTipDelegate.genericName;
+        }
+
+        let text = display;
+        if (toolTipDelegate.isGroup && text === "") {
+            return "";
+        }
+
+        // Normally the window title will always have " — [app name]" at the end of
+        // the window-provided title. But if it doesn't, this is intentional 100%
+        // of the time because the developer or user has deliberately removed that
+        // part, so just display it with no more fancy processing.
+        if (!text.match(/\s+(—|-|–)/)) {
+            return text;
+        }
+
+        // KWin appends increasing integers in between pointy brackets to otherwise equal window titles.
+        // In this case save <#number> as counter and delete it at the end of text.
+        text = `${(text.match(/.*(?=\s+(—|-|–))/) || [""])[0]}${(text.match(/<\d+>/) || [""]).pop()}`;
+
+        // In case the window title had only redundant information (i.e. appName), text is now empty.
+        // Add a hyphen to indicate that and avoid empty space.
+        if (text === "") {
+            text = "—";
+        }
+        return text;
+    }
+
+    readonly property bool titleIncludesTrack: toolTipDelegate.playerData !== null && title.includes(toolTipDelegate.playerData.track)
+
+    // Lots of spacing with no thumbnails looks bad
+    spacing: Plasmoid.configuration.showToolTips ? Kirigami.Units.smallSpacing : 0
+
+    // text labels + close button
+    Item {
+        id: headerItem
+        implicitHeight: header.height
+        implicitWidth: header.implicitWidth
+        Layout.fillWidth: true
+
+        // This number controls the overall size of the window tooltips
+        Layout.maximumWidth: toolTipDelegate.tooltipInstanceMaximumWidth
+        Layout.minimumWidth: (toolTipDelegate.isWin && Plasmoid.configuration.showToolTips) || toolTipDelegate.isGroup ? Layout.maximumWidth : 0
+        Layout.alignment: Qt.AlignHCenter | Qt.AlignVCenter
+        // match margins of DefaultToolTip.qml in plasma-framework
+        Layout.margins: toolTipDelegate.isWin && Plasmoid.configuration.showToolTips ? 0 : Kirigami.Units.gridUnit / 2
+
+        RowLayout {
+            id: header
+            width: parent.width
+            // match spacing of DefaultToolTip.qml in plasma-framework
+            spacing: Kirigami.Units.smallSpacing
+
+            // close button for right edge ltr and left edge rtl
+            LayoutItemProxy {
+                id: closeButtonFlippedItemProxy
+                target: closeButton
+                visible: toolTipDelegate.isWin &&
+                    ((Plasmoid.location == PlasmaCore.Types.LeftEdge &&
+                      Application.layoutDirection == Qt.RightToLeft) ||
+                     (Plasmoid.location == PlasmaCore.Types.RightEdge &&
+                      Application.layoutDirection == Qt.LeftToRight))
+            }
+
+            // all textlabels
+            ColumnLayout {
+                spacing: 0
+                // app name
+                Kirigami.Heading {
+                    id: appNameHeading
+                    level: 3
+                    maximumLineCount: 1
+                    Layout.fillWidth: true
+                    lineHeight: toolTipDelegate.isWin && Plasmoid.configuration.showToolTips ? 1 : appNameHeading.lineHeight
+                    elide: Text.ElideRight
+                    text: toolTipDelegate.appName
+                    color: (headerHoverHandler.visible && headerHoverHighlight.pressed) ? Kirigami.Theme.highlightedTextColor : Kirigami.Theme.textColor
+                    opacity: root.index === 0 ? 1 : 0
+                    visible: (text.length !== 0) && (root.orientation === ListView.Horizontal || root.index === 0)
+                    textFormat: Text.PlainText
+                }
+                // window title
+                PlasmaComponents3.Label {
+                    id: winTitle
+                    maximumLineCount: 1
+                    Layout.fillWidth: true
+                    elide: Text.ElideRight
+                    property bool somethingVisible: (thumbnailSourceItem.visible ||
+                        appNameHeading.visible || subtext.visible)
+                    text: ((root.titleIncludesTrack && playerController.active) ||
+                           (root.title === appNameHeading.text && somethingVisible))
+                          ? "" : root.title
+                    color: (headerHoverHandler.visible && headerHoverHighlight.pressed) ? Kirigami.Theme.highlightedTextColor : Kirigami.Theme.textColor
+                    opacity: 0.75
+                    visible: root.orientation === ListView.Horizontal || text.length !== 0
+                    textFormat: Text.PlainText
+                }
+                // subtext
+                PlasmaComponents3.Label {
+                    id: subtext
+                    maximumLineCount: 2
+                    Layout.fillWidth: true
+                    elide: Text.ElideRight
+                    text: toolTipDelegate.isWin ? root.generateSubText() : ""
+                    color: (headerHoverHandler.visible && headerHoverHighlight.pressed) ? Kirigami.Theme.highlightedTextColor : Kirigami.Theme.textColor
+                    opacity: 0.75
+                    visible: text.length !== 0 && text !== appNameHeading.text
+                    textFormat: Text.PlainText
+                }
+            }
+
+            // Count badge.
+            // The badge itself is inside an item to better center the text in the bubble
+            Item {
+                Layout.alignment: !Plasmoid.configuration.showToolTips && !playerController.active && !volumeControls.active ? Qt.AlignVCenter : Qt.AlignTop
+                Layout.preferredHeight: closeButton.height
+                Layout.preferredWidth: closeButton.width
+                visible: root.index === 0 && toolTipDelegate.smartLauncherCountVisible
+
+                Badge {
+                    anchors.centerIn: parent
+                    height: Kirigami.Units.iconSizes.smallMedium
+                    number: toolTipDelegate.smartLauncherCount
+                }
+            }
+
+            LayoutItemProxy {
+                target: closeButton
+                visible: toolTipDelegate.isWin && !closeButtonFlippedItemProxy.visible
+            }
+
+            // close button
+            PlasmaComponents3.ToolButton {
+                id: closeButton
+                Layout.alignment: Qt.AlignTop
+                Layout.rightMargin: closeButtonFlippedItemProxy.visible ? headerItem.Layout.margins : -headerItem.Layout.margins
+                Layout.leftMargin: closeButtonFlippedItemProxy.visible ? -headerItem.Layout.margins : headerItem.Layout.margins
+                Layout.topMargin: -headerItem.Layout.margins
+                icon.name: "window-close"
+                onClicked: {
+                    tasks.cancelHighlightWindows();
+                    tasksModel.requestClose(root.submodelIndex);
+                }
+                PlasmaComponents3.ToolTip.text: i18nc("@info:tooltip Close this window", "Close window")
+                PlasmaComponents3.ToolTip.visible: root.visible && hovered
+                PlasmaComponents3.ToolTip.delay: Kirigami.Units.toolTipDelay
+            }
+        }
+
+        // make the header clickable if image tooltips are disabled (and thus there is no other clickable area that activates the window)
+        // headerHoverHandler has to be unloaded after the instance is pooled in order to avoid getting the old containsMouse status when the same instance is reused, so put it in a Loader.
+        Loader {
+            id: headerHoverHandler
+            active: (root.index !== -1) && !Plasmoid.configuration.showToolTips
+            z: -2
+            anchors.fill: headerItem
+            anchors.margins: -headerItem.Layout.margins
+            sourceComponent: ToolTipWindowMouseArea {
+                rootTask: toolTipDelegate.parentTask
+                modelIndex: root.submodelIndex
+                winId: thumbnailSourceItem.winId
+            }
+        }
+
+        // There's no PlasmaComponents3 version
+        PlasmaExtras.Highlight {
+            id: headerHoverHighlight
+            anchors.fill: headerHoverHandler
+            z: -1
+            visible: (headerHoverHandler.item as MouseArea)?.containsMouse ?? false
+            pressed: (headerHoverHandler.item as MouseArea)?.containsPress ?? false
+            hovered: true
+        }
+    }
+
+    // thumbnail container
+    Item {
+        id: thumbnailSourceItem
+
+        Layout.fillWidth: true
+        Layout.preferredHeight: Kirigami.Units.gridUnit * 8
+
+        clip: true
+        visible: Plasmoid.configuration.showToolTips && toolTipDelegate.isWin
+
+        readonly property /*undefined|WId where WId = int|string*/ var winId:
+            toolTipDelegate.isWin ? toolTipDelegate.windows[root.index] : undefined
+
+        // There's no PlasmaComponents3 version
+        PlasmaExtras.Highlight {
+            anchors.fill: hoverHandler
+            visible: (hoverHandler.item as MouseArea)?.containsMouse ?? false
+            pressed: (hoverHandler.item as MouseArea)?.containsPress ?? false
+            hovered: true
+        }
+
+        Loader {
+            id: thumbnailLoader
+            active: !toolTipDelegate.isLauncher
+                && !albumArtImage.visible
+                && (Number.isInteger(thumbnailSourceItem.winId) || pipeWireLoader.item
+                && !(pipeWireLoader.item as PipeWireThumbnail).hasThumbnail)
+                && root.index !== -1 // Avoid loading when the instance is going to be destroyed
+            asynchronous: true
+            visible: active
+            anchors.fill: hoverHandler
+            // Indent a little bit so that neither the thumbnail nor the drop
+            // shadow can cover up the highlight
+            anchors.margins: Kirigami.Units.smallSpacing * 2
+
+            sourceComponent: root.isMinimized || pipeWireLoader.active ? iconItem : x11Thumbnail
+
+            Component {
+                id: x11Thumbnail
+
+                PlasmaCore.WindowThumbnail {
+                    winId: thumbnailSourceItem.winId
+                }
+            }
+
+            // when minimized, we don't have a preview on X11, so show the icon
+            Component {
+                id: iconItem
+
+                Kirigami.Icon {
+                    id: realIconItem
+                    source: toolTipDelegate.icon
+                    animated: false
+                    visible: valid
+                    opacity: pipeWireLoader.active ? 0 : 1
+
+                    SequentialAnimation {
+                        running: true
+
+                        PauseAnimation {
+                            duration: Kirigami.Units.humanMoment
+                        }
+
+                        NumberAnimation {
+                            id: showAnimation
+                            duration: Kirigami.Units.longDuration
+                            easing.type: Easing.OutCubic
+                            property: "opacity"
+                            target: realIconItem
+                            to: 1
+                        }
+                    }
+
+                }
+            }
+        }
+
+        Loader {
+            id: pipeWireLoader
+            anchors.fill: hoverHandler
+            // Indent a little bit so that neither the thumbnail nor the drop
+            // shadow can cover up the highlight
+            anchors.margins: thumbnailLoader.anchors.margins
+
+            active: Plasmoid.configuration.showToolTips
+                && !toolTipDelegate.isLauncher
+                && !albumArtImage.visible
+                && KWindowSystem.isPlatformWayland
+                && root.index !== -1
+            asynchronous: true
+            //In a loader since we might not have PipeWire available yet (WITH_PIPEWIRE could be undefined in plasma-workspace/libtaskmanager/declarative/taskmanagerplugin.cpp)
+            source: "PipeWireThumbnail.qml"
+        }
+
+        Loader {
+            active: Plasmoid.configuration.showToolTips
+                && (((pipeWireLoader.item as PipeWireThumbnail)?.hasThumbnail ?? false) || (thumbnailLoader.status === Loader.Ready && !root.isMinimized))
+            asynchronous: true
+            visible: active
+            anchors.fill: pipeWireLoader.active ? pipeWireLoader : thumbnailLoader
+
+            sourceComponent: GE.DropShadow {
+                horizontalOffset: 0
+                verticalOffset: 3
+                radius: 8
+                samples: Math.round(radius * 1.5)
+                color: "Black"
+                source: pipeWireLoader.active ? pipeWireLoader.item : thumbnailLoader.item // source could be undefined when albumArt is available, so put it in a Loader.
+            }
+        }
+
+        Loader {
+            active: Plasmoid.configuration.showToolTips
+                && albumArtImage.visible
+                && albumArtImage.status === Image.Ready
+                && root.index !== -1 // Avoid loading when the instance is going to be destroyed
+            asynchronous: true
+            visible: active
+            anchors.centerIn: hoverHandler
+
+            sourceComponent: ShaderEffect {
+                id: albumArtBackground
+                readonly property Image source: albumArtImage
+
+                // Manual implementation of Image.PreserveAspectCrop
+                readonly property real scaleFactor: Math.max(hoverHandler.width / source.paintedWidth, hoverHandler.height / source.paintedHeight)
+                width: Math.round(source.paintedWidth * scaleFactor)
+                height: Math.round(source.paintedHeight * scaleFactor)
+                layer.enabled: true
+                opacity: 0.25
+                layer.effect: GE.FastBlur {
+                    source: albumArtBackground
+                    anchors.fill: source
+                    radius: 30
+                }
+            }
+        }
+
+        Image {
+            id: albumArtImage
+            // also Image.Loading to prevent loading thumbnails just because the album art takes a split second to load
+            // if this is a group tooltip, we check if window title and track match, to allow distinguishing the different windows
+            // if this app is a browser, we also check the title, so album art is not shown when the user is on some other tab
+            // in all other cases we can safely show the album art without checking the title
+            readonly property bool available: (status === Image.Ready || status === Image.Loading)
+                && (!(toolTipDelegate.isGroup || backend.applicationCategories(launcherUrl).includes("WebBrowser")) || root.titleIncludesTrack)
+
+            anchors.fill: hoverHandler
+            // Indent by one pixel to make sure we never cover up the entire highlight
+            anchors.margins: 1
+            sourceSize: Qt.size(parent.width, parent.height)
+
+            asynchronous: true
+            retainWhileLoading: true
+            source: toolTipDelegate.playerData?.artUrl ?? ""
+            fillMode: Image.PreserveAspectFit
+            visible: available
+        }
+
+        // hoverHandler has to be unloaded after the instance is pooled in order to avoid getting the old containsMouse status when the same instance is reused, so put it in a Loader.
+        Loader {
+            id: hoverHandler
+            active: root.index !== -1
+            anchors.fill: parent
+            sourceComponent: ToolTipWindowMouseArea {
+                rootTask: toolTipDelegate.parentTask
+                modelIndex: root.submodelIndex
+                winId: thumbnailSourceItem.winId
+            }
+        }
+    }
+
+    // Player controls row, load on demand so group tooltips could be loaded faster
+    Loader {
+        id: playerController
+        // Only load for one entry, as the controls only apply to one window.
+        // If this is changed in the future, test for index != -1 to avoid loading
+        // when the instance is going to be destroyed
+        active: (toolTipDelegate.parentTask?.tooltipControlsEnabled
+             && toolTipDelegate.playerData
+             && ((root.hasTrackInATitle && albumArtImage.available) || (!root.hasTrackInATitle && root.index == 0))) ?? false
+
+        asynchronous: true
+        visible: active
+        Layout.fillWidth: true
+        Layout.maximumWidth: headerItem.Layout.maximumWidth
+        Layout.leftMargin: headerItem.Layout.margins
+        Layout.rightMargin: headerItem.Layout.margins
+
+        source: "PlayerController.qml"
+    }
+
+    // Volume controls
+    Loader {
+        id: volumeControls
+        active: toolTipDelegate.parentTask !== null
+             && pulseAudio.item !== null
+             && toolTipDelegate.parentTask.tooltipControlsEnabled
+             && toolTipDelegate.parentTask.hasAudioStream
+             // Only load for one entry, as the controls only apply to one window.
+             // If this is changed in the future, test for index != -1 to avoid loading
+             // when the instance is going to be destroyed
+             && ((hasTrackInATitle && albumArtImage.available) || (!hasTrackInATitle && root.index == 0))
+        asynchronous: true
+        visible: active
+        Layout.fillWidth: true
+        Layout.maximumWidth: headerItem.Layout.maximumWidth
+        Layout.leftMargin: headerItem.Layout.margins
+        Layout.rightMargin: headerItem.Layout.margins
+        sourceComponent: RowLayout {
+            PlasmaComponents3.ToolButton { // Mute button
+                id: muteButton
+                icon.width: Kirigami.Units.iconSizes.small
+                icon.height: Kirigami.Units.iconSizes.small
+                icon.name: {
+                    let finalIcon = ""
+
+                    if (checked) {
+                        finalIcon = "audio-volume-muted"
+                    } else if (slider.displayValue <= 25) {
+                        finalIcon = "audio-volume-low"
+                    } else if (slider.displayValue <= 75) {
+                        finalIcon = "audio-volume-medium"
+                    } else {
+                        finalIcon = "audio-volume-high"
+                    }
+
+                    if (mirrored) {
+                        finalIcon = finalIcon + "-rtl"
+                    }
+
+                    return finalIcon
+                }
+                onClicked: toolTipDelegate.parentTask.toggleMuted()
+                checked: toolTipDelegate.parentTask.muted
+
+                PlasmaComponents3.ToolTip {
+                    text: muteButton.checked
+                        ? i18nc("button to unmute app", "Unmute %1", toolTipDelegate.parentTask.appName)
+                        : i18nc("button to mute app", "Mute %1", toolTipDelegate.parentTask.appName)
+                }
+            }
+
+            PlasmaComponents3.Slider {
+                id: slider
+
+                readonly property int displayValue: Math.round(value / to * 100)
+                readonly property int loudestVolume: toolTipDelegate.parentTask.audioStreams
+                    .reduce((loudestVolume, stream) => Math.max(loudestVolume, stream.volume), 0)
+
+                Layout.fillWidth: true
+                from: pulseAudio.item.minimalVolume
+                to: pulseAudio.item.normalVolume
+                value: loudestVolume
+                stepSize: to / 100
+                opacity: toolTipDelegate.parentTask.muted ? 0.5 : 1
+
+                Accessible.name: i18nc("Accessibility data on volume slider", "Adjust volume for %1", toolTipDelegate.parentTask.appName)
+
+                onMoved: toolTipDelegate.parentTask.audioStreams.forEach((stream) => {
+                    let v = Math.max(from, value)
+                    if (v > 0 && loudestVolume > 0) { // prevent divide by 0
+                        // adjust volume relative to the loudest stream
+                        v = Math.min(Math.round(stream.volume / loudestVolume * v), to)
+                    }
+                    stream.model.Volume = v
+                    stream.model.Muted = v === 0
+                })
+            }
+            PlasmaComponents3.Label { // percent label
+                Layout.alignment: Qt.AlignHCenter
+                Layout.minimumWidth: percentMetrics.advanceWidth
+                horizontalAlignment: Qt.AlignRight
+                text: i18nc("volume percentage", "%1%", slider.displayValue)
+                textFormat: Text.PlainText
+                TextMetrics {
+                    id: percentMetrics
+                    text: i18nc("only used for sizing, should be widest possible string", "100%")
+                }
+            }
+        }
+    }
+
+    function generateSubText(): string {
+        const subTextEntries = [];
+
+        if (!Plasmoid.configuration.showOnlyCurrentDesktop && virtualDesktopInfo.numberOfDesktops > 1) {
+            if (!isOnAllVirtualDesktops && virtualDesktops.length > 0) {
+                const virtualDesktopNameList = virtualDesktops.map(virtualDesktop => {
+                    const index = virtualDesktopInfo.desktopIds.indexOf(virtualDesktop);
+                    return virtualDesktopInfo.desktopNames[index];
+                });
+
+                subTextEntries.push(i18nc("Comma-separated list of desktops", "On %1",
+                    virtualDesktopNameList.join(", ")));
+            } else if (isOnAllVirtualDesktops) {
+                subTextEntries.push(i18nc("Comma-separated list of desktops", "Pinned to all desktops"));
+            }
+        }
+
+        if (activities.length === 0 && activityInfo.numberOfRunningActivities > 1) {
+            subTextEntries.push(i18nc("Which virtual desktop a window is currently on",
+                "Available on all activities"));
+        } else if (activities.length > 0) {
+            const activityNames = activities
+                .filter(activity => activity !== activityInfo.currentActivity)
+                .map(activity => activityInfo.activityName(activity))
+                .filter(activityName => activityName !== "");
+
+            if (Plasmoid.configuration.showOnlyCurrentActivity) {
+                if (activityNames.length > 0) {
+                    subTextEntries.push(i18nc("Activities a window is currently on (apart from the current one)",
+                        "Also available on %1", activityNames.join(", ")));
+                }
+            } else if (activityNames.length > 0) {
+                subTextEntries.push(i18nc("Which activities a window is currently on",
+                    "Available on %1", activityNames.join(", ")));
+            }
+        }
+
+        return subTextEntries.join("\n");
+    }
+}
diff --git a/applets/taskmanager_compact/qml/ToolTipWindowMouseArea.qml b/applets/taskmanager_compact/qml/ToolTipWindowMouseArea.qml
new file mode 100644
index 0000000000..aa709f67ba
--- /dev/null
+++ b/applets/taskmanager_compact/qml/ToolTipWindowMouseArea.qml
@@ -0,0 +1,42 @@
+/*
+    SPDX-FileCopyrightText: 2013 Sebastian Kügler <sebas@kde.org>
+    SPDX-FileCopyrightText: 2014 Martin Gräßlin <mgraesslin@kde.org>
+    SPDX-FileCopyrightText: 2016 Kai Uwe Broulik <kde@privat.broulik.de>
+
+    SPDX-License-Identifier: LGPL-2.0-or-later
+*/
+
+pragma ComponentBehavior: Bound
+
+import QtQuick
+
+MouseArea {
+    required property /*QModelIndex*/var modelIndex
+    required property /*undefined|WId where WId = int|string*/ var winId
+    required property Task rootTask
+
+    acceptedButtons: Qt.LeftButton | Qt.MiddleButton | Qt.RightButton
+    hoverEnabled: true
+    enabled: winId !== undefined
+
+    onClicked: (mouse) => {
+        switch (mouse.button) {
+        case Qt.LeftButton:
+            tasksModel.requestActivate(modelIndex);
+            rootTask.hideImmediately();
+            tasks.cancelHighlightWindows();
+            break;
+        case Qt.MiddleButton:
+            tasks.cancelHighlightWindows();
+            tasksModel.requestClose(modelIndex);
+            break;
+        case Qt.RightButton:
+            tasks.createContextMenu(rootTask, modelIndex).show();
+            break;
+        }
+    }
+
+    onContainsMouseChanged: {
+        tasks.windowsHovered([String(winId)], containsMouse);
+    }
+}
diff --git a/applets/taskmanager_compact/qml/code/LayoutMetrics.js b/applets/taskmanager_compact/qml/code/LayoutMetrics.js
new file mode 100644
index 0000000000..895cc725d2
--- /dev/null
+++ b/applets/taskmanager_compact/qml/code/LayoutMetrics.js
@@ -0,0 +1,164 @@
+/*
+    SPDX-FileCopyrightText: 2012-2013 Eike Hein <hein@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+.import org.kde.kirigami as Kirigami
+
+const iconMargin = Math.round(Kirigami.Units.smallSpacing / 4);
+const labelMargin = Kirigami.Units.smallSpacing;
+
+function horizontalMargins() {
+    const spacingAdjustment = (tasks.plasmoid.pluginName === "org.kde.plasma.icontasks") ? (Kirigami.Settings.tabletMode ? 3 : tasks.plasmoid.configuration.iconSpacing) : 1
+    return (taskFrame.margins.left + taskFrame.margins.right) * (tasks.vertical ? 1 : spacingAdjustment);
+}
+
+function verticalMargins() {
+    const spacingAdjustment = (tasks.plasmoid.pluginName === "org.kde.plasma.icontasks") ? (Kirigami.Settings.tabletMode ? 3 : tasks.plasmoid.configuration.iconSpacing) : 1
+    return (taskFrame.margins.top + taskFrame.margins.bottom) * (tasks.vertical ? spacingAdjustment : 1);
+}
+
+function adjustMargin(height, margin) {
+    const available = height - verticalMargins();
+
+    if (available < Kirigami.Units.iconSizes.small) {
+        return Math.floor((margin * (Kirigami.Units.iconSizes.small / available)) / 3);
+    }
+
+    return margin;
+}
+
+function maxStripes() {
+    const length = tasks.vertical ? tasks.width : tasks.height;
+    const minimum = tasks.vertical ? preferredMinWidth() : preferredMinHeight();
+
+    return Math.min(tasks.plasmoid.configuration.maxStripes, Math.max(1, Math.floor(length / minimum)));
+}
+
+function optimumCapacity(width, height) {
+    const length = tasks.vertical ? height : width;
+    const maximum = tasks.vertical ? preferredMaxHeight() : preferredMaxWidth();
+
+    if (!tasks.vertical) {
+        //  Fit more tasks in this case, that is possible to cut text, before combining tasks.
+        return Math.ceil(length / maximum) * maxStripes() + 1;
+    }
+
+    return Math.floor(length / maximum) * maxStripes();
+}
+
+function preferredMinWidth() {
+    let width = preferredMinLauncherWidth();
+
+    if (!tasks.vertical && !tasks.iconsOnly) {
+      width +=
+          (Kirigami.Units.smallSpacing * 2) +
+          (Kirigami.Units.gridUnit * 8);
+    }
+
+    return width;
+}
+
+function preferredMaxWidth() {
+    if (tasks.iconsOnly) {
+        if (tasks.vertical) {
+            if (tasks.width === 0) {
+                return 0
+            }
+            return tasks.width + verticalMargins();
+        } else {
+            if (tasks.height === 0) {
+                return 0
+            }
+            return tasks.height + horizontalMargins();
+        }
+    }
+
+    // Avoid doing a bunch of unnecessary work below in vertical mode
+    if (tasks.vertical) {
+        return preferredMinWidth();
+    }
+
+    // Visually, a large max item width on a tall panel looks cluttered even
+    // with just a task or two open. This clutter is less pronounced on panels
+    // lower in height, as there is generally more horizontal space.
+    //
+    // This allows for one default value for max item width where clutter is
+    // reduced at low task counts for tall panels, while leaving low height
+    // panels less affected (unaffected at 20px).
+    const laneHeight = tasks.height / maxStripes(); // correct for multiple rows
+    let baseFactor = 1; // sane default in case something goes wrong
+    switch (tasks.plasmoid.configuration.taskMaxWidth) {
+    case 0: // narrow
+        baseFactor = 1.2;
+        break;
+    case 1: // medium
+        baseFactor = 1.6;
+        break;
+    case 2: // wide
+        baseFactor = 2;
+        break;
+    }
+    // For every pixel of height above 20, knock the factor down by 0.01. This
+    // produces nice results for 20~50 pixels. Above 50, it suddenly feels like
+    // it's shrinking a lot, and above 80 the Medium and Narrow settings would
+    // end up setting the same width, so don't apply further reduction above 50.
+    const factorReduction = (Math.min(50, laneHeight) - 20) * 0.01;
+    // Clamp the minimum factor to 1 to ensure max width is always >= min width.
+    // and the factor reduction to 0 so we don't ever increase the factor
+    const factor = Math.max(1, baseFactor - Math.max(0, factorReduction));
+    return Math.floor(preferredMinWidth() * factor);
+}
+
+function preferredMinHeight() {
+    // TODO FIXME UPSTREAM: Port to proper font metrics for descenders once we have access to them.
+    return Kirigami.Units.iconSizes.sizeForLabels + 4;
+}
+
+function preferredMaxHeight() {
+    if (tasks.vertical) {
+        let taskPreferredSize = 0;
+        if (tasks.iconsOnly) {
+            taskPreferredSize = tasks.width / maxStripes();
+        } else {
+            taskPreferredSize = Math.max(Kirigami.Units.iconSizes.sizeForLabels,
+                                         Kirigami.Units.iconSizes.medium);
+        }
+        return verticalMargins() +
+            Math.min(
+                // Do not allow the preferred icon size to exceed the width of
+                // the vertical task manager.
+                tasks.width / maxStripes(),
+                taskPreferredSize);
+    } else {
+        return verticalMargins() +
+            Math.min(
+                Kirigami.Units.iconSizes.small * 3,
+                Kirigami.Units.iconSizes.sizeForLabels * 3);
+    }
+}
+
+function preferredHeightInPopup() {
+    return verticalMargins() + Math.max(Kirigami.Units.iconSizes.sizeForLabels,
+                                        Kirigami.Units.iconSizes.medium);
+}
+
+function spaceRequiredToShowText() {
+    // gridUnit is the height of the default font, but only one isn't enough to
+    // show anything but the elision character. 2 is too high and results in
+    // text appearing only at excessively high widths.
+    return Math.round(Kirigami.Units.gridUnit * 1.5);
+}
+
+function preferredMinLauncherWidth() {
+    const baseWidth = tasks.vertical ? preferredMinHeight() : Math.min(tasks.height, Kirigami.Units.iconSizes.small * 3);
+
+    return (baseWidth + horizontalMargins())
+        - (adjustMargin(baseWidth, taskFrame.margins.top) + adjustMargin(baseWidth, taskFrame.margins.bottom));
+}
+
+function maximumContextMenuTextWidth() {
+    return (Kirigami.Units.iconSizes.sizeForLabels * 28);
+}
+
diff --git a/applets/taskmanager_compact/qml/code/TaskTools.js b/applets/taskmanager_compact/qml/code/TaskTools.js
new file mode 100644
index 0000000000..b16a25d131
--- /dev/null
+++ b/applets/taskmanager_compact/qml/code/TaskTools.js
@@ -0,0 +1,259 @@
+/*
+    SPDX-FileCopyrightText: 2012-2016 Eike Hein <hein@kde.org>
+    SPDX-FileCopyrightText: 2020 Nate Graham <nate@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+.pragma library
+
+.import org.kde.taskmanager as TaskManager
+.import org.kde.plasma.core as PlasmaCore // Needed by TaskManager
+
+// Can't be `let`, or else QML counterpart won't be able to assign to it.
+var taskManagerInstanceCount = 0;
+
+function activateNextPrevTask(anchor, next, wheelSkipMinimized, wheelEnabled, tasks) {
+    // FIXME TODO: Unnecessarily convoluted and costly; optimize.
+
+    if (wheelEnabled === 2) { // TaskOnly
+        // anchor can be undefined if scrolling on an empty area
+        if (!anchor) return;
+        // Get the number of open windows for the application
+        const anchorModelIndex = anchor.modelIndex(anchor.index);
+        const winIdList = tasks.tasksModel.data(anchorModelIndex, TaskManager.AbstractTasksModel.WinIdList);
+        const windowCount = winIdList ? winIdList.length : 0;
+        // No windows
+        if (windowCount === 0) {
+            return;
+        }
+
+        // Single window
+        if (windowCount === 1) {
+            const isHidden = tasks.tasksModel.data(anchorModelIndex, TaskManager.AbstractTasksModel.IsHidden);
+            if (!wheelSkipMinimized || !isHidden) {
+                tasks.tasksModel.requestActivate(anchorModelIndex);
+            }
+            return;
+        }
+    }
+
+    // Multiple windows
+    let taskIndexList = [];
+    const activeTaskIndex = tasks.tasksModel.activeTask;
+
+    for (let i = 0; i < tasks.taskList.children.length - 1; ++i) {
+        const task = tasks.taskList.children[i];
+        const modelIndex = task.modelIndex(i);
+
+        if (!task.model.IsLauncher && !task.model.IsStartup) {
+            if (task.model.IsGroupParent) {
+                if (wheelEnabled === 2 && task === anchor) { // If TaskOnly mode and the anchor is a group parent, collect only windows within the group.
+                    taskIndexList = [];
+                }
+
+                for (let j = 0; j < tasks.tasksModel.rowCount(modelIndex); ++j) {
+                    const childModelIndex = tasks.tasksModel.makeModelIndex(i, j);
+                    const childHidden = tasks.tasksModel.data(childModelIndex, TaskManager.AbstractTasksModel.IsHidden);
+                    if (!wheelSkipMinimized || !childHidden) {
+                        taskIndexList.push(childModelIndex);
+                    }
+                }
+
+                if (wheelEnabled === 2 && task === anchor) { // If TaskOnly mode, break after processing the anchor group.
+                    break;
+                }
+            } else {
+                if (!wheelSkipMinimized || !task.model.IsHidden) {
+                    taskIndexList.push(modelIndex);
+                }
+            }
+        }
+    }
+
+    if (!taskIndexList.length) {
+        return;
+    }
+
+    let target = taskIndexList[0];
+
+    for (let i = 0; i < taskIndexList.length; ++i) {
+        if (taskIndexList[i] === activeTaskIndex)
+        {
+            if (next && i < (taskIndexList.length - 1)) {
+                target = taskIndexList[i + 1];
+            } else if (!next) {
+                if (i) {
+                    target = taskIndexList[i - 1];
+                } else {
+                    target = taskIndexList[taskIndexList.length - 1];
+                }
+            }
+
+            break;
+        }
+    }
+
+    tasks.tasksModel.requestActivate(target);
+}
+
+// Get the model index of the task with the maximum value for `attribute`,
+// or `undefined` if the attribute is undefined for all tasks in the group (for instance LastActivated may be undefined)
+function groupTopTask(childTaskList, attribute, tasks) {
+    let topAttribute = -1;
+    let topTaskIndex = undefined;
+
+    for (let task = 0; task < childTaskList.length; ++task) {
+        const childTaskModelIndex = childTaskList[task];
+        const taskAttribute = tasks.tasksModel.data(childTaskModelIndex, attribute);
+
+        if (taskAttribute !== undefined && taskAttribute > topAttribute) {
+            topAttribute = taskAttribute;
+            topTaskIndex = childTaskModelIndex;
+        }
+    }
+
+    return topTaskIndex;
+}
+
+function activateTask(index, model, modifiers, task, plasmoid, tasks, windowViewAvailable) {
+    if (modifiers & Qt.ShiftModifier) {
+        tasks.tasksModel.requestNewInstance(index);
+        return;
+    }
+    // Publish delegate geometry again if there are more than one task manager instance
+    if (taskManagerInstanceCount >= 2) {
+        tasks.tasksModel.requestPublishDelegateGeometry(task.modelIndex(), tasks.backend.globalRect(task), task);
+    }
+
+    if (model.IsGroupParent) {
+        // Option 1 (default): Cycle through this group's tasks
+        // ====================================================
+        // If the grouped task does not include the currently active task, bring
+        // forward the most recently used task in the group.
+        // Otherwise cycle through all tasks in the group without paying attention
+        // to the last activation time, which otherwise would change with every click
+        if (plasmoid.configuration.groupedTaskVisualization === 0) {
+            let childTaskList = [];
+
+            for (let i = 0; i < tasks.tasksModel.rowCount(task.modelIndex(index)); ++i) {
+                const childTaskModelIndex = tasks.tasksModel.makeModelIndex(task.index, i);
+                childTaskList.push(childTaskModelIndex);
+            }
+
+            // If the active task is already among in the group that was
+            // activated, cycle through all tasks according to the order of
+            // the immutable model index so the order doesn't change with
+            // every click.
+            if (childTaskList.some(index => tasks.tasksModel.data(index, TaskManager.AbstractTasksModel.IsActive))) {
+                for (let j = 0; j < childTaskList.length; ++j) {
+                    const childTask = childTaskList[j];
+                    if (tasks.tasksModel.data(childTask, TaskManager.AbstractTasksModel.IsActive)) {
+                        // Found the current task. Activate the next one
+                        let nextTask = j + 1;
+                        if (nextTask >= childTaskList.length) {
+                            nextTask = 0;
+                        }
+                        tasks.tasksModel.requestActivate(childTaskList[nextTask]);
+                        break;
+                    }
+                }
+            } else {
+                // If the active task is from a different app from the group that
+                // was clicked on switch to the last-used task from that app.
+                let topTaskIndex = groupTopTask(childTaskList, TaskManager.AbstractTasksModel.LastActivated, tasks);
+
+                // If no task in the group was ever active, the LastActivated property is not set on any task
+                // -> default to the stacking order
+                if (topTaskIndex === undefined) {
+                    topTaskIndex = groupTopTask(childTaskList, TaskManager.AbstractTasksModel.StackingOrder, tasks)
+                }
+
+                tasks.tasksModel.requestActivate(topTaskIndex);
+            }
+        }
+
+        // Option 2: show tooltips for all child tasks
+        // ===========================================
+        else if (plasmoid.configuration.groupedTaskVisualization === 1) {
+            if (tasks.toolTipOpenedByClick) {
+                task.hideImmediately();
+            } else {
+                tasks.toolTipOpenedByClick = task;
+                task.updateMainItemBindings(); // BUG 452187
+                task.showToolTip();
+            }
+        }
+
+        // Option 3: show Window View for all child tasks
+        // ==================================================
+        // Make sure the Window View effect is  are actually enabled though;
+        // if not, fall through to the next option.
+        else if (plasmoid.configuration.groupedTaskVisualization === 2 && windowViewAvailable) {
+            task.hideToolTip();
+            tasks.activateWindowView(model.WinIdList);
+        }
+
+        // Option 4: show group dialog/textual list
+        // ========================================
+        // This is also the final fallback option if Window View
+        // is chosen but not actually available
+        else {
+            if (tasks.groupDialog) {
+                task.hideToolTip();
+                tasks.groupDialog.visible = false;
+            } else {
+                createGroupDialog(task, tasks);
+            }
+        }
+    } else {
+        if (model.IsMinimized) {
+            tasks.tasksModel.requestToggleMinimized(index);
+            tasks.tasksModel.requestActivate(index);
+        } else if (model.IsActive && plasmoid.configuration.minimizeActiveTaskOnClick) {
+            tasks.tasksModel.requestToggleMinimized(index);
+        } else {
+            tasks.tasksModel.requestActivate(index);
+        }
+    }
+}
+
+function taskPrefix(prefix, location) {
+    let effectivePrefix;
+
+    switch (location) {
+    case PlasmaCore.Types.LeftEdge:
+        effectivePrefix = "west-" + prefix;
+        break;
+    case PlasmaCore.Types.TopEdge:
+        effectivePrefix = "north-" + prefix;
+        break;
+    case PlasmaCore.Types.RightEdge:
+        effectivePrefix = "east-" + prefix;
+        break;
+    default:
+        effectivePrefix = "south-" + prefix;
+    }
+    return [effectivePrefix, prefix];
+}
+
+function taskPrefixHovered(prefix, location) {
+    return [
+        ...taskPrefix((prefix || "launcher") + "-hover", location),
+        ...prefix ? taskPrefix("hover", location) : [],
+        ...taskPrefix(prefix, location),
+    ];
+}
+
+function createGroupDialog(visualParent, tasks) {
+    if (!visualParent) {
+        return;
+    }
+
+    if (tasks.groupDialog) {
+        tasks.groupDialog.visualParent = visualParent;
+        return;
+    }
+
+    tasks.groupDialog = tasks.groupDialogComponent.createObject(tasks, { visualParent });
+}
diff --git a/applets/taskmanager_compact/qml/config.qml b/applets/taskmanager_compact/qml/config.qml
new file mode 100644
index 0000000000..78458e832b
--- /dev/null
+++ b/applets/taskmanager_compact/qml/config.qml
@@ -0,0 +1,22 @@
+/*
+    SPDX-FileCopyrightText: 2013 Eike Hein <hein@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+import QtQuick
+
+import org.kde.plasma.configuration
+
+ConfigModel {
+    ConfigCategory {
+         name: i18nc("@title:group for configuration dialog page", "Appearance")
+         icon: "preferences-desktop-color"
+         source: "ConfigAppearance.qml"
+    }
+    ConfigCategory {
+         name: i18nc("@title:group for configuration dialog page", "Behavior")
+         icon: "preferences-desktop"
+         source: "ConfigBehavior.qml"
+    }
+}
diff --git a/applets/taskmanager_compact/qml/main.qml b/applets/taskmanager_compact/qml/main.qml
new file mode 100644
index 0000000000..8befa68427
--- /dev/null
+++ b/applets/taskmanager_compact/qml/main.qml
@@ -0,0 +1,572 @@
+/*
+    SPDX-FileCopyrightText: 2012-2016 Eike Hein <hein@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+pragma ComponentBehavior: Bound
+
+import QtQuick
+import QtQuick.Layouts
+
+import org.kde.plasma.plasmoid
+import org.kde.plasma.components as PlasmaComponents3
+import org.kde.plasma.core as PlasmaCore
+import org.kde.ksvg as KSvg
+import org.kde.plasma.private.mpris as Mpris
+import org.kde.kirigami as Kirigami
+
+import org.kde.plasma.workspace.trianglemousefilter
+
+import org.kde.taskmanager as TaskManager
+import plasma.applet.org.kde.plasma.taskmanager.compact as TaskManagerApplet
+import org.kde.plasma.workspace.dbus as DBus
+
+PlasmoidItem {
+    id: tasks
+
+    // For making a bottom to top layout since qml flow can't do that.
+    // We just hang the task manager upside down to achieve that.
+    // This mirrors the tasks and group dialog as well, so we un-rotate them
+    // to fix that (see Task.qml and GroupDialog.qml).
+    rotation: Plasmoid.configuration.reverseMode && Plasmoid.formFactor === PlasmaCore.Types.Vertical ? 180 : 0
+
+    readonly property bool shouldShrinkToZero: tasksModel.count === 0
+    readonly property bool vertical: Plasmoid.formFactor === PlasmaCore.Types.Vertical
+    readonly property bool iconsOnly: Plasmoid.pluginName === "org.kde.plasma.icontasks"
+
+    property Task toolTipOpenedByClick
+    property Task toolTipAreaItem
+
+    readonly property Component contextMenuComponent: Qt.createComponent("ContextMenu.qml")
+    readonly property Component pulseAudioComponent: Qt.createComponent("PulseAudio.qml")
+
+    property alias taskList: taskList
+
+    preferredRepresentation: fullRepresentation
+
+    Plasmoid.constraintHints: Plasmoid.CanFillArea
+
+    Plasmoid.onUserConfiguringChanged: {
+        if (Plasmoid.userConfiguring && groupDialog !== null) {
+            groupDialog.visible = false;
+        }
+    }
+
+    Layout.fillWidth: vertical ? true : Plasmoid.configuration.fill
+    Layout.fillHeight: !vertical ? true : Plasmoid.configuration.fill
+    Layout.minimumWidth: {
+        if (shouldShrinkToZero) {
+            return Kirigami.Units.gridUnit; // For edit mode
+        }
+        return vertical ? 0 : TaskManagerApplet.LayoutMetrics.preferredMinWidth();
+    }
+    Layout.minimumHeight: {
+        if (shouldShrinkToZero) {
+            return Kirigami.Units.gridUnit; // For edit mode
+        }
+        return !vertical ? 0 : TaskManagerApplet.LayoutMetrics.preferredMinHeight();
+    }
+
+//BEGIN TODO: this is not precise enough: launchers are smaller than full tasks
+    Layout.preferredWidth: {
+        if (shouldShrinkToZero) {
+            return 0.01;
+        }
+        if (vertical) {
+            return Kirigami.Units.gridUnit * 10;
+        }
+        return taskList.Layout.maximumWidth
+    }
+    Layout.preferredHeight: {
+        if (shouldShrinkToZero) {
+            return 0.01;
+        }
+        if (vertical) {
+            return taskList.Layout.maximumHeight
+        }
+        return Kirigami.Units.gridUnit * 2;
+    }
+//END TODO
+
+    property Item dragSource
+
+    signal requestLayout
+
+    onDragSourceChanged: {
+        if (dragSource === null) {
+            tasksModel.syncLaunchers();
+        }
+    }
+
+    function windowsHovered(winIds: var, hovered: bool): DBus.DBusPendingReply {
+        if (!Plasmoid.configuration.highlightWindows) {
+            return;
+        }
+        return DBus.SessionBus.asyncCall({service: "org.kde.KWin.HighlightWindow", path: "/org/kde/KWin/HighlightWindow", iface: "org.kde.KWin.HighlightWindow", member: "highlightWindows", arguments: [hovered ? winIds : []], signature: "(as)"});
+    }
+
+    function cancelHighlightWindows(): DBus.DBusPendingReply {
+        return DBus.SessionBus.asyncCall({service: "org.kde.KWin.HighlightWindow", path: "/org/kde/KWin/HighlightWindow", iface: "org.kde.KWin.HighlightWindow", member: "highlightWindows", arguments: [[]], signature: "(as)"});
+    }
+
+    function activateWindowView(winIds: var): DBus.DBusPendingReply {
+        if (!effectWatcher.registered) {
+            return;
+        }
+        cancelHighlightWindows();
+        return DBus.SessionBus.asyncCall({service: "org.kde.KWin.Effect.WindowView1", path: "/org/kde/KWin/Effect/WindowView1", iface: "org.kde.KWin.Effect.WindowView1", member: "activate", arguments: [winIds.map(s => String(s))], signature: "(as)"});
+    }
+
+    function publishIconGeometries(taskItems: /*list<Item>*/var): void {
+        if (TaskManagerApplet.TaskTools.taskManagerInstanceCount >= 2) {
+            return;
+        }
+        for (let i = 0; i < taskItems.length - 1; ++i) {
+            const task = taskItems[i];
+
+            if (!task.model.IsLauncher && !task.model.IsStartup) {
+                tasksModel.requestPublishDelegateGeometry(tasksModel.makeModelIndex(task.index),
+                    backend.globalRect(task), task);
+            }
+        }
+    }
+
+    readonly property TaskManager.TasksModel tasksModel: TaskManager.TasksModel {
+        id: tasksModel
+
+        readonly property int logicalLauncherCount: {
+            if (Plasmoid.configuration.separateLaunchers) {
+                return launcherCount;
+            }
+
+            let startupsWithLaunchers = 0;
+
+            for (let i = 0; i < taskRepeater.count; ++i) {
+                const item = taskRepeater.itemAt(i) as Task;
+
+                // During destruction required properties such as item.model can go null for a while,
+                // so in paths that can trigger on those moments, they need to be guarded
+                if (item?.model?.IsStartup && item.model.HasLauncher) {
+                    ++startupsWithLaunchers;
+                }
+            }
+
+            return launcherCount + startupsWithLaunchers;
+        }
+
+        virtualDesktop: virtualDesktopInfo.currentDesktop
+        screenGeometry: Plasmoid.containment.screenGeometry
+        activity: activityInfo.currentActivity
+
+        filterByVirtualDesktop: Plasmoid.configuration.showOnlyCurrentDesktop
+        filterByScreen: Plasmoid.configuration.showOnlyCurrentScreen
+        filterByActivity: Plasmoid.configuration.showOnlyCurrentActivity
+        filterNotMinimized: Plasmoid.configuration.showOnlyMinimized
+
+        hideActivatedLaunchers: tasks.iconsOnly || Plasmoid.configuration.hideLauncherOnStart
+        sortMode: sortModeEnumValue(Plasmoid.configuration.sortingStrategy)
+        launchInPlace: tasks.iconsOnly && Plasmoid.configuration.sortingStrategy === 1
+        separateLaunchers: {
+            if (!tasks.iconsOnly && !Plasmoid.configuration.separateLaunchers
+                && Plasmoid.configuration.sortingStrategy === 1) {
+                return false;
+            }
+
+            return true;
+        }
+
+        groupMode: groupModeEnumValue(Plasmoid.configuration.groupingStrategy)
+        groupInline: !Plasmoid.configuration.groupPopups && !tasks.iconsOnly
+        groupingWindowTasksThreshold: (Plasmoid.configuration.onlyGroupWhenFull && !tasks.iconsOnly
+            ? TaskManagerApplet.LayoutMetrics.optimumCapacity(tasks.width, tasks.height) + 1 : -1)
+
+        onLauncherListChanged: {
+            Plasmoid.configuration.launchers = launcherList;
+        }
+
+        onGroupingAppIdBlacklistChanged: {
+            Plasmoid.configuration.groupingAppIdBlacklist = groupingAppIdBlacklist;
+        }
+
+        onGroupingLauncherUrlBlacklistChanged: {
+            Plasmoid.configuration.groupingLauncherUrlBlacklist = groupingLauncherUrlBlacklist;
+        }
+
+        function sortModeEnumValue(index: int): /*TaskManager.TasksModel.SortMode*/ int {
+            switch (index) {
+            case 0:
+                return TaskManager.TasksModel.SortDisabled;
+            case 1:
+                return TaskManager.TasksModel.SortManual;
+            case 2:
+                return TaskManager.TasksModel.SortAlpha;
+            case 3:
+                return TaskManager.TasksModel.SortVirtualDesktop;
+            case 4:
+                return TaskManager.TasksModel.SortActivity;
+            // 5 is SortLastActivated, skipped
+            case 6:
+                return TaskManager.TasksModel.SortWindowPositionHorizontal;
+            default:
+                return TaskManager.TasksModel.SortDisabled;
+            }
+        }
+
+        function groupModeEnumValue(index: int): /*TaskManager.TasksModel.GroupMode*/ int {
+            switch (index) {
+            case 0:
+                return TaskManager.TasksModel.GroupDisabled;
+            case 1:
+                return TaskManager.TasksModel.GroupApplications;
+            }
+        }
+
+        Component.onCompleted: {
+            launcherList = Plasmoid.configuration.launchers;
+            groupingAppIdBlacklist = Plasmoid.configuration.groupingAppIdBlacklist;
+            groupingLauncherUrlBlacklist = Plasmoid.configuration.groupingLauncherUrlBlacklist;
+
+            // Only hook up view only after the above churn is done.
+            taskRepeater.model = tasksModel;
+        }
+    }
+
+    readonly property TaskManagerApplet.Backend backend: TaskManagerApplet.Backend {
+        id: backend
+
+        onAddLauncher: url => {
+            tasks.addLauncher(url);
+        }
+    }
+
+    DBus.DBusServiceWatcher {
+        id: effectWatcher
+        busType: DBus.BusType.Session
+        watchedService: "org.kde.KWin.Effect.WindowView1"
+    }
+
+    readonly property Component taskInitComponent: Component {
+        Timer {
+            interval: 200
+            running: true
+
+            onTriggered: {
+                const task = parent as Task;
+                if (task) {
+                    tasks.tasksModel.requestPublishDelegateGeometry(task.modelIndex(), tasks.backend.globalRect(task), task);
+                }
+                destroy();
+            }
+        }
+    }
+
+    Connections {
+        target: Plasmoid
+
+        function onLocationChanged(): void {
+            if (TaskManagerApplet.TaskTools.taskManagerInstanceCount >= 2) {
+                return;
+            }
+            // This is on a timer because the panel may not have
+            // settled into position yet when the location prop-
+            // erty updates.
+            iconGeometryTimer.start();
+        }
+    }
+
+    Connections {
+        target: Plasmoid.containment
+
+        function onScreenGeometryChanged(): void {
+            iconGeometryTimer.start();
+        }
+    }
+
+    Mpris.Mpris2Model {
+        id: mpris2Source
+    }
+
+    Item {
+        anchors.fill: parent
+
+        TaskManager.VirtualDesktopInfo {
+            id: virtualDesktopInfo
+        }
+
+        TaskManager.ActivityInfo {
+            id: activityInfo
+            readonly property string nullUuid: "00000000-0000-0000-0000-000000000000"
+        }
+
+        Loader {
+            id: pulseAudio
+            sourceComponent: tasks.pulseAudioComponent
+            active: tasks.pulseAudioComponent.status === Component.Ready
+        }
+
+        Timer {
+            id: iconGeometryTimer
+
+            interval: 500
+            repeat: false
+
+            onTriggered: {
+                tasks.publishIconGeometries(taskList.children, tasks);
+            }
+        }
+
+        Binding {
+            target: Plasmoid
+            property: "status"
+            value: (tasksModel.anyTaskDemandsAttention && Plasmoid.configuration.unhideOnAttention
+                ? PlasmaCore.Types.NeedsAttentionStatus : PlasmaCore.Types.PassiveStatus)
+            restoreMode: Binding.RestoreBinding
+        }
+
+        Connections {
+            target: Plasmoid.configuration
+
+            function onLaunchersChanged(): void {
+                tasksModel.launcherList = Plasmoid.configuration.launchers
+            }
+            function onGroupingAppIdBlacklistChanged(): void {
+                tasksModel.groupingAppIdBlacklist = Plasmoid.configuration.groupingAppIdBlacklist;
+            }
+            function onGroupingLauncherUrlBlacklistChanged(): void {
+                tasksModel.groupingLauncherUrlBlacklist = Plasmoid.configuration.groupingLauncherUrlBlacklist;
+            }
+        }
+
+        Component {
+            id: busyIndicator
+            PlasmaComponents3.BusyIndicator {}
+        }
+
+        // Save drag data
+        Item {
+            id: dragHelper
+
+            Drag.dragType: Drag.Automatic
+            Drag.supportedActions: Qt.CopyAction | Qt.MoveAction | Qt.LinkAction
+            Drag.onDragFinished: dropAction => {
+                tasks.dragSource = null;
+            }
+        }
+
+        KSvg.FrameSvgItem {
+            id: taskFrame
+
+            visible: false
+
+            imagePath: "widgets/tasks"
+            prefix: TaskManagerApplet.TaskTools.taskPrefix("normal", Plasmoid.location)
+        }
+
+        MouseHandler {
+            id: mouseHandler
+
+            anchors.fill: parent
+
+            target: taskList
+
+            onUrlsDropped: urls => {
+                // If all dropped URLs point to application desktop files, we'll add a launcher for each of them.
+                const createLaunchers = urls.every(item => tasks.backend.isApplication(item));
+
+                if (createLaunchers) {
+                    urls.forEach(item => addLauncher(item));
+                    return;
+                }
+
+                if (!hoveredItem) {
+                    return;
+                }
+
+                // Otherwise we'll just start a new instance of the application with the URLs as argument,
+                // as you probably don't expect some of your files to open in the app and others to spawn launchers.
+                tasksModel.requestOpenUrls((hoveredItem as Task).modelIndex(), urls);
+            }
+        }
+
+        ToolTipDelegate {
+            id: openWindowToolTipDelegate
+            visible: false
+        }
+
+        ToolTipDelegate {
+            id: pinnedAppToolTipDelegate
+            visible: false
+        }
+
+        TriangleMouseFilter {
+            id: tmf
+            filterTimeOut: 300
+            active: tasks.toolTipAreaItem && tasks.toolTipAreaItem.toolTipOpen
+            blockFirstEnter: false
+
+            edge: {
+                switch (Plasmoid.location) {
+                case PlasmaCore.Types.BottomEdge:
+                    return Qt.TopEdge;
+                case PlasmaCore.Types.TopEdge:
+                    return Qt.BottomEdge;
+                case PlasmaCore.Types.LeftEdge:
+                    return Qt.RightEdge;
+                case PlasmaCore.Types.RightEdge:
+                    return Qt.LeftEdge;
+                default:
+                    return Qt.TopEdge;
+                }
+            }
+
+            LayoutMirroring.enabled: tasks.shouldBeMirrored(Plasmoid.configuration.reverseMode, Application.layoutDirection, tasks.vertical)
+            anchors {
+                left: parent.left
+                top: parent.top
+            }
+
+            height: taskList.height
+            width: taskList.width
+
+            TaskList {
+                id: taskList
+
+                LayoutMirroring.enabled: tasks.shouldBeMirrored(Plasmoid.configuration.reverseMode, Application.layoutDirection, tasks.vertical)
+                anchors {
+                    left: parent.left
+                    top: parent.top
+                }
+
+                count: tasksModel.count
+
+                readonly property real widthOccupation: taskRepeater.count / columns
+                readonly property real heightOccupation: taskRepeater.count / rows
+
+                Layout.maximumWidth: {
+                    const totalMaxWidth = children.reduce((accumulator, child) => {
+                            if (!isFinite(child.Layout.maximumWidth)) {
+                                return accumulator;
+                            }
+                            return accumulator + child.Layout.maximumWidth
+                        }, 0);
+                    return Math.round(totalMaxWidth / widthOccupation);
+                }
+                Layout.maximumHeight: {
+                    const totalMaxHeight = children.reduce((accumulator, child) => {
+                            if (!isFinite(child.Layout.maximumHeight)) {
+                                return accumulator;
+                            }
+                            return accumulator + child.Layout.maximumHeight
+                        }, 0);
+                    return Math.round(totalMaxHeight / heightOccupation);
+                }
+                width: {
+                    if (tasks.shouldShrinkToZero) {
+                        return 0;
+                    }
+                    if (tasks.vertical) {
+                        return tasks.width * Math.min(1, widthOccupation);
+                    } else {
+                        return Math.min(tasks.width, Layout.maximumWidth);
+                    }
+                }
+                height: {
+                    if (tasks.shouldShrinkToZero) {
+                        return 0;
+                    }
+                    if (tasks.vertical) {
+                        return Math.min(tasks.height, Layout.maximumHeight);
+                    } else {
+                        return tasks.height * Math.min(1, heightOccupation);
+                    }
+                }
+
+                flow: {
+                    if (tasks.vertical) {
+                        return Plasmoid.configuration.forceStripes ? Grid.LeftToRight : Grid.TopToBottom
+                    }
+                    return Plasmoid.configuration.forceStripes ? Grid.TopToBottom : Grid.LeftToRight
+                }
+
+                onAnimatingChanged: {
+                    if (!animating) {
+                        tasks.publishIconGeometries(children, tasks);
+                    }
+                }
+
+                Repeater {
+                    id: taskRepeater
+
+                    delegate: Task {
+                        tasksRoot: tasks
+                    }
+                }
+            }
+        }
+    }
+
+    readonly property Component groupDialogComponent: Qt.createComponent("GroupDialog.qml")
+    property GroupDialog groupDialog
+
+    readonly property bool supportsLaunchers: true
+
+    function hasLauncher(url: url): bool {
+        return tasksModel.launcherPosition(url) !== -1;
+    }
+
+    function addLauncher(url: url): void {
+        if (Plasmoid.immutability !== PlasmaCore.Types.SystemImmutable) {
+            tasksModel.requestAddLauncher(url);
+        }
+    }
+
+    function removeLauncher(url: url): void {
+        if (Plasmoid.immutability !== PlasmaCore.Types.SystemImmutable) {
+            tasksModel.requestRemoveLauncher(url);
+        }
+    }
+
+    // This is called by plasmashell in response to a Meta+number shortcut.
+    // TODO: Change type to int
+    function activateTaskAtIndex(index: var): void {
+        if (typeof index !== "number") {
+            return;
+        }
+
+        const task = taskRepeater.itemAt(index) as Task;
+        if (task) {
+            TaskManagerApplet.TaskTools.activateTask(task.modelIndex(), task.model, null, task, Plasmoid, this, effectWatcher.registered);
+        }
+    }
+
+    function createContextMenu(rootTask, modelIndex, args = {}) {
+        const initialArgs = Object.assign(args, {
+            visualParent: rootTask,
+            modelIndex,
+            mpris2Source,
+            backend,
+        });
+        return contextMenuComponent.createObject(rootTask, initialArgs);
+    }
+
+    function shouldBeMirrored(reverseMode, layoutDirection, vertical): bool {
+        // LayoutMirroring is only horizontal
+        if (vertical) {
+            return layoutDirection === Qt.RightToLeft;
+        }
+
+        if (layoutDirection === Qt.LeftToRight) {
+            return reverseMode;
+        }
+        return !reverseMode;
+    }
+
+    Component.onCompleted: {
+        TaskManagerApplet.TaskTools.taskManagerInstanceCount += 1;
+        requestLayout.connect(iconGeometryTimer.restart);
+    }
+
+    Component.onDestruction: {
+        TaskManagerApplet.TaskTools.taskManagerInstanceCount -= 1;
+    }
+}
diff --git a/applets/taskmanager_compact/smartlauncherbackend.cpp b/applets/taskmanager_compact/smartlauncherbackend.cpp
new file mode 100644
index 0000000000..803b447ede
--- /dev/null
+++ b/applets/taskmanager_compact/smartlauncherbackend.cpp
@@ -0,0 +1,251 @@
+/*
+    SPDX-FileCopyrightText: 2016, 2019 Kai Uwe Broulik <kde@privat.broulik.de>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+#include "smartlauncherbackend.h"
+
+#include <QDBusConnection>
+#include <QDBusMessage>
+#include <QDBusServiceWatcher>
+#include <QDebug>
+
+#include <KConfigGroup>
+#include <KService>
+#include <KSharedConfig>
+
+#include <algorithm>
+#include <cmath>
+
+#include "log_settings.h"
+#include <settings.h>
+
+using namespace SmartLauncher;
+using namespace NotificationManager;
+
+Backend::Backend(QObject *parent)
+    : QObject(parent)
+    , m_watcher(new QDBusServiceWatcher(this))
+    , m_jobsModel(nullptr)
+    , m_settings(new Settings(this))
+{
+    m_watcher->setConnection(QDBusConnection::sessionBus());
+    m_watcher->setWatchMode(QDBusServiceWatcher::WatchForUnregistration);
+    connect(m_watcher, &QDBusServiceWatcher::serviceUnregistered, this, &Backend::onServiceUnregistered);
+
+    setupUnity();
+
+    reload();
+    connect(m_settings, &Settings::settingsChanged, this, &Backend::reload);
+}
+
+Backend::~Backend() = default;
+
+void Backend::reload()
+{
+    m_badgeBlacklist = m_settings->badgeBlacklistedApplications();
+
+    // Unity Launcher API operates on storage IDs ("foo.desktop"), whereas settings return desktop entries "foo"
+    std::transform(m_badgeBlacklist.begin(), m_badgeBlacklist.end(), m_badgeBlacklist.begin(), [](const QString &desktopEntry) -> QString {
+        return desktopEntry + QStringLiteral(".desktop");
+    });
+
+    if (!m_jobsModel) {
+        m_jobsModel = JobsModel::createJobsModel();
+        m_jobsModel->init();
+    }
+
+    Q_EMIT reloadRequested(QString() /*all*/);
+}
+
+bool Backend::doNotDisturbMode() const
+{
+    return m_settings->notificationsInhibitedByApplication()
+        || (m_settings->notificationsInhibitedUntil().isValid() && m_settings->notificationsInhibitedUntil() > QDateTime::currentDateTimeUtc());
+}
+
+void Backend::setupUnity()
+{
+    auto sessionBus = QDBusConnection::sessionBus();
+
+    if (!sessionBus.connect({},
+                            {},
+                            QStringLiteral("com.canonical.Unity.LauncherEntry"),
+                            QStringLiteral("Update"),
+                            this,
+                            SLOT(update(QString, QMap<QString, QVariant>)))) {
+        qCWarning(TASKMANAGER_DEBUG) << "failed to register Update signal";
+        return;
+    }
+
+    if (!sessionBus.registerObject(QStringLiteral("/Unity"), this)) {
+        qCWarning(TASKMANAGER_DEBUG) << "Failed to register unity object";
+        return;
+    }
+
+    if (!sessionBus.registerService(QStringLiteral("com.canonical.Unity"))) {
+        qCWarning(TASKMANAGER_DEBUG) << "Failed to register unity service";
+        // In case an external process uses this (e.g. Latte Dock), let it just listen.
+    }
+
+    KConfigGroup grp(KSharedConfig::openConfig(QStringLiteral("taskmanagerrulesrc")), QStringLiteral("Unity Launcher Mapping"));
+
+    const QStringList keys = grp.keyList();
+    for (const QString &key : keys) {
+        const QString &value = grp.readEntry(key, QString());
+        if (value.isEmpty()) {
+            continue;
+        }
+
+        m_unityMappingRules.insert(key, value);
+    }
+}
+
+bool Backend::hasLauncher(const QString &storageId) const
+{
+    return m_launchers.contains(storageId);
+}
+
+int Backend::count(const QString &uri) const
+{
+    if (!m_settings->badgesInTaskManager() || doNotDisturbMode() || m_badgeBlacklist.contains(uri)) {
+        return 0;
+    }
+    return m_launchers.value(uri).count;
+}
+
+bool Backend::countVisible(const QString &uri) const
+{
+    if (!m_settings->badgesInTaskManager() || doNotDisturbMode() || m_badgeBlacklist.contains(uri)) {
+        return false;
+    }
+    return m_launchers.value(uri).countVisible;
+}
+
+int Backend::progress(const QString &uri) const
+{
+    return m_launchers.value(uri).progress;
+}
+
+bool Backend::progressVisible(const QString &uri) const
+{
+    return m_launchers.value(uri).progressVisible;
+}
+
+bool Backend::urgent(const QString &uri) const
+{
+    return m_launchers.value(uri).urgent;
+}
+
+QHash<QString, QString> Backend::unityMappingRules() const
+{
+    return m_unityMappingRules;
+}
+
+void Backend::update(const QString &uri, const QMap<QString, QVariant> &properties)
+{
+    Q_ASSERT(calledFromDBus());
+
+    QString storageId;
+
+    auto foundStorageId = m_launcherUrlToStorageId.constFind(uri);
+    if (foundStorageId == m_launcherUrlToStorageId.constEnd()) { // we don't know this one, register
+        // According to Unity Launcher API documentation applications *should* send along their
+        // desktop file name with application:// prefix
+        const QString applicationSchemePrefix = QStringLiteral("application://");
+
+        QString normalizedUri = uri;
+        if (normalizedUri.startsWith(applicationSchemePrefix)) {
+            normalizedUri = uri.mid(applicationSchemePrefix.length());
+        }
+
+        KService::Ptr service = KService::serviceByStorageId(normalizedUri);
+        if (!service) {
+            qCWarning(TASKMANAGER_DEBUG) << "Failed to find service for Unity Launcher" << uri;
+            return;
+        }
+
+        storageId = service->storageId();
+        m_launcherUrlToStorageId.insert(uri, storageId);
+
+        m_dbusServiceToLauncherUrl.insert(message().service(), uri);
+        m_watcher->addWatchedService(message().service());
+    } else {
+        storageId = *foundStorageId;
+    }
+
+    auto foundEntry = m_launchers.find(storageId);
+    if (foundEntry == m_launchers.end()) { // we don't have it yet, create a new Entry
+        Entry entry;
+        foundEntry = m_launchers.insert(storageId, entry);
+    }
+
+    auto propertiesEnd = properties.constEnd();
+
+    auto foundCount = properties.constFind(QStringLiteral("count"));
+    if (foundCount != propertiesEnd) {
+        qint64 newCount = foundCount->toLongLong();
+        // 2 billion unread emails ought to be enough for anybody
+        if (newCount < std::numeric_limits<int>::max()) {
+            int saneCount = static_cast<int>(newCount);
+            if (saneCount != foundEntry->count) {
+                foundEntry->count = saneCount;
+                Q_EMIT countChanged(storageId, saneCount);
+            }
+        }
+    }
+
+    updateLauncherProperty(storageId, properties, QStringLiteral("count"), &foundEntry->count, &Backend::count, &Backend::countChanged);
+    updateLauncherProperty(storageId,
+                           properties,
+                           QStringLiteral("count-visible"),
+                           &foundEntry->countVisible,
+                           &Backend::countVisible,
+                           &Backend::countVisibleChanged);
+
+    // the API gives us progress as 0..1 double but we'll use percent to avoid unnecessary
+    // changes when it just changed a fraction of a percent, hence not using our fancy updateLauncherProperty method
+    auto foundProgress = properties.constFind(QStringLiteral("progress"));
+    if (foundProgress != propertiesEnd) {
+        const int oldSanitizedProgress = progress(storageId);
+
+        double progressValue = foundProgress->toDouble();
+        if (!std::isfinite(progressValue)) {
+            progressValue = 0.0; // Treat NaN/Inf as zero
+        }
+        foundEntry->progress = qRound(progressValue * 100);
+
+        const int newSanitizedProgress = progress(storageId);
+
+        if (oldSanitizedProgress != newSanitizedProgress) {
+            Q_EMIT progressChanged(storageId, newSanitizedProgress);
+        }
+    }
+
+    updateLauncherProperty(storageId,
+                           properties,
+                           QStringLiteral("progress-visible"),
+                           &foundEntry->progressVisible,
+                           &Backend::progressVisible,
+                           &Backend::progressVisibleChanged);
+    updateLauncherProperty(storageId, properties, QStringLiteral("urgent"), &foundEntry->urgent, &Backend::urgent, &Backend::urgentChanged);
+}
+
+void Backend::onServiceUnregistered(const QString &service)
+{
+    const QString &launcherUrl = m_dbusServiceToLauncherUrl.take(service);
+    if (launcherUrl.isEmpty()) {
+        return;
+    }
+
+    const QString &storageId = m_launcherUrlToStorageId.take(launcherUrl);
+    if (storageId.isEmpty()) {
+        return;
+    }
+
+    m_launchers.remove(storageId);
+    Q_EMIT launcherRemoved(storageId);
+}
+
+#include "moc_smartlauncherbackend.cpp"
diff --git a/applets/taskmanager_compact/smartlauncherbackend.h b/applets/taskmanager_compact/smartlauncherbackend.h
new file mode 100644
index 0000000000..5354efb85f
--- /dev/null
+++ b/applets/taskmanager_compact/smartlauncherbackend.h
@@ -0,0 +1,120 @@
+/*
+    SPDX-FileCopyrightText: 2016, 2019 Kai Uwe Broulik <kde@privat.broulik.de>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+#pragma once
+
+#include <QDBusContext>
+#include <QHash>
+#include <QObject>
+#include <QVariantMap>
+
+#include <jobsmodel.h>
+
+class QDBusServiceWatcher;
+class QString;
+
+namespace NotificationManager
+{
+class Settings;
+}
+
+namespace SmartLauncher
+{
+struct Entry {
+    int count = 0;
+    bool countVisible = false;
+    int progress = 0;
+    bool progressVisible = false;
+    bool urgent = false;
+};
+
+class Backend : public QObject, protected QDBusContext
+{
+    Q_OBJECT
+
+public:
+    explicit Backend(QObject *parent = nullptr);
+    ~Backend() override;
+
+    bool hasLauncher(const QString &storageId) const;
+
+    int count(const QString &uri) const;
+    bool countVisible(const QString &uri) const;
+    int progress(const QString &uri) const;
+    bool progressVisible(const QString &uri) const;
+    bool urgent(const QString &uri) const;
+
+    QHash<QString, QString> unityMappingRules() const;
+
+Q_SIGNALS:
+    void countChanged(const QString &uri, int count);
+    void countVisibleChanged(const QString &uri, bool countVisible);
+    void progressChanged(const QString &uri, int progress);
+    void progressVisibleChanged(const QString &uri, bool progressVisible);
+    void urgentChanged(const QString &uri, bool urgent);
+
+    void reloadRequested(const QString &uri);
+    void launcherRemoved(const QString &uri);
+
+private Q_SLOTS:
+    void update(const QString &uri, const QMap<QString, QVariant> &properties);
+
+private:
+    void reload();
+    void setupUnity();
+    void setupApplicationJobs();
+
+    void onServiceUnregistered(const QString &service);
+
+    template<typename T>
+    void updateLauncherProperty(const QString &storageId, // our KService storage id
+                                const QVariantMap &properties, // the map of properties we're given by DBus
+                                const QString &property, // the property we're looking for
+                                T *entryMember, // the member variable we're going to write our result in
+                                // the getter for this property which might return something different from the raw value
+                                T (Backend::*getter)(const QString &) const,
+                                // the change signal that will be emitted if the property has changed
+                                void (Backend::*changeSignal)(const QString &, T))
+    {
+        auto foundProperty = properties.constFind(property);
+        if (foundProperty != properties.constEnd()) {
+            const T oldSanitizedValue = ((this)->*getter)(storageId);
+
+            T newValue = foundProperty->value<T>();
+            *entryMember = newValue;
+
+            const T newSanitizedValue = ((this)->*getter)(storageId);
+
+            if (newSanitizedValue != oldSanitizedValue) {
+                Q_EMIT((this)->*changeSignal)(storageId, newSanitizedValue);
+            }
+        }
+    }
+
+    bool doNotDisturbMode() const;
+
+    // Unity Launchers
+    QDBusServiceWatcher *m_watcher;
+    QHash<QString, QString> m_dbusServiceToLauncherUrl;
+    QHash<QString, QString> m_launcherUrlToStorageId;
+    // these rules can be configured in the taskmanagerrulesrc in the "Unity Launcher Mapping" section
+    // key is the actual desktop file name of the application (some-broken-app-beta.desktop)
+    // value is how it actually announces itself on the Unity API (some-broken-app.desktop)
+    QHash<QString, QString> m_unityMappingRules;
+
+    // Application Jobs
+    NotificationManager::JobsModel::Ptr m_jobsModel;
+
+    NotificationManager::Settings *m_settings = nullptr;
+
+    QHash<QString, Entry> m_launchers;
+
+    QStringList m_badgeBlacklist;
+
+    bool m_available = false;
+};
+
+} // namespace SmartLauncher
diff --git a/applets/taskmanager_compact/smartlauncheritem.cpp b/applets/taskmanager_compact/smartlauncheritem.cpp
new file mode 100644
index 0000000000..2eadd2fa93
--- /dev/null
+++ b/applets/taskmanager_compact/smartlauncheritem.cpp
@@ -0,0 +1,225 @@
+/*
+    SPDX-FileCopyrightText: 2016, 2019 Kai Uwe Broulik <kde@privat.broulik.de>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+#include "smartlauncheritem.h"
+
+#include <KDesktopFile>
+#include <KService>
+
+#include "log_settings.h"
+
+using namespace SmartLauncher;
+
+Item::Item(QObject *parent)
+    : QObject(parent)
+{
+    m_backendPtr = s_backend.lock();
+    if (!m_backendPtr) {
+        auto ptr = std::make_shared<Backend>();
+        s_backend = ptr;
+        m_backendPtr = s_backend.lock();
+    }
+}
+
+std::weak_ptr<Backend> Item::s_backend;
+
+void Item::init()
+{
+    if (m_inited || m_storageId.isEmpty() || !m_backendPtr) {
+        return;
+    }
+
+    connect(m_backendPtr.get(), &Backend::reloadRequested, this, [this](const QString &uri) {
+        if (uri.isEmpty() || m_storageId == uri) {
+            populate();
+        }
+    });
+
+    connect(m_backendPtr.get(), &Backend::launcherRemoved, this, [this](const QString &uri) {
+        if (uri.isEmpty() || m_storageId == uri) {
+            clear();
+        }
+    });
+
+    connect(m_backendPtr.get(), &Backend::countChanged, this, [this](const QString &uri, int count) {
+        if (uri.isEmpty() || m_storageId == uri) {
+            setCount(count);
+        }
+    });
+
+    connect(m_backendPtr.get(), &Backend::countVisibleChanged, this, [this](const QString &uri, bool countVisible) {
+        if (uri.isEmpty() || m_storageId == uri) {
+            setCountVisible(countVisible);
+        }
+    });
+
+    connect(m_backendPtr.get(), &Backend::progressChanged, this, [this](const QString &uri, int progress) {
+        if (uri.isEmpty() || m_storageId == uri) {
+            setProgress(progress);
+        }
+    });
+
+    connect(m_backendPtr.get(), &Backend::progressVisibleChanged, this, [this](const QString &uri, bool progressVisible) {
+        if (uri.isEmpty() || m_storageId == uri) {
+            setProgressVisible(progressVisible);
+        }
+    });
+
+    connect(m_backendPtr.get(), &Backend::urgentChanged, this, [this](const QString &uri, bool urgent) {
+        if (uri.isEmpty() || m_storageId == uri) {
+            setUrgent(urgent);
+        }
+    });
+
+    m_inited = true;
+}
+
+void Item::populate()
+{
+    if (!m_backendPtr || m_storageId.isEmpty()) {
+        return;
+    }
+
+    if (!m_backendPtr->hasLauncher(m_storageId)) {
+        return;
+    }
+
+    setCount(m_backendPtr->count(m_storageId));
+    setCountVisible(m_backendPtr->countVisible(m_storageId));
+    setProgress(m_backendPtr->progress(m_storageId));
+    setProgressVisible(m_backendPtr->progressVisible(m_storageId));
+    setUrgent(m_backendPtr->urgent(m_storageId));
+}
+
+void Item::clear()
+{
+    setCount(0);
+    setCountVisible(false);
+    setProgress(0);
+    setProgressVisible(false);
+    setUrgent(false);
+}
+
+QUrl Item::launcherUrl() const
+{
+    return m_launcherUrl;
+}
+
+void Item::setLauncherUrl(const QUrl &launcherUrl)
+{
+    if (launcherUrl != m_launcherUrl) {
+        m_launcherUrl = launcherUrl;
+        Q_EMIT launcherUrlChanged(launcherUrl);
+
+        m_storageId.clear();
+        clear();
+
+        if (launcherUrl.scheme() == QLatin1String("applications")) {
+            const KService::Ptr service = KService::serviceByMenuId(launcherUrl.path());
+
+            if (service && launcherUrl.path() == service->menuId()) {
+                m_storageId = service->menuId();
+            }
+        }
+
+        if (launcherUrl.isLocalFile() && KDesktopFile::isDesktopFile(launcherUrl.toLocalFile())) {
+            KDesktopFile f(launcherUrl.toLocalFile());
+
+            const KService::Ptr service = KService::serviceByStorageId(f.fileName());
+            if (service) {
+                m_storageId = service->storageId();
+            }
+        }
+
+        if (m_storageId.isEmpty()) {
+            return;
+        }
+
+        if (m_backendPtr) {
+            // check if we have a mapping to a different desktop file
+            const QString &overrideStorageId = m_backendPtr->unityMappingRules().value(m_storageId);
+            if (!overrideStorageId.isEmpty()) {
+                m_storageId = overrideStorageId;
+            }
+        }
+
+        init();
+        populate();
+    }
+}
+
+int Item::count() const
+{
+    return m_count;
+}
+
+void Item::setCount(int count)
+{
+    if (m_count != count) {
+        m_count = count;
+        Q_EMIT countChanged(count);
+    }
+}
+
+bool Item::countVisible() const
+{
+    return m_countVisible;
+}
+
+void Item::setCountVisible(bool countVisible)
+{
+    if (m_countVisible != countVisible) {
+        m_countVisible = countVisible;
+        Q_EMIT countVisibleChanged(countVisible);
+    }
+}
+
+int Item::progress() const
+{
+    return m_progress;
+}
+
+void Item::setProgress(int progress)
+{
+    int boundedProgress = std::clamp(progress, 0, 100);
+
+    if (progress != boundedProgress) {
+        qCDebug(TASKMANAGER_DEBUG).nospace() << qUtf8Printable(m_launcherUrl.toString()) << ": Progress value " << progress << " is out of bounds!";
+    }
+
+    if (m_progress != boundedProgress) {
+        m_progress = boundedProgress;
+        Q_EMIT progressChanged(boundedProgress);
+    }
+}
+
+bool Item::progressVisible() const
+{
+    return m_progressVisible;
+}
+
+void Item::setProgressVisible(bool progressVisible)
+{
+    if (m_progressVisible != progressVisible) {
+        m_progressVisible = progressVisible;
+        Q_EMIT progressVisibleChanged(progressVisible);
+    }
+}
+
+bool Item::urgent() const
+{
+    return m_urgent;
+}
+
+void Item::setUrgent(bool urgent)
+{
+    if (m_urgent != urgent) {
+        m_urgent = urgent;
+        Q_EMIT urgentChanged(urgent);
+    }
+}
+
+#include "moc_smartlauncheritem.cpp"
diff --git a/applets/taskmanager_compact/smartlauncheritem.h b/applets/taskmanager_compact/smartlauncheritem.h
new file mode 100644
index 0000000000..eb06b43aaa
--- /dev/null
+++ b/applets/taskmanager_compact/smartlauncheritem.h
@@ -0,0 +1,82 @@
+/*
+    SPDX-FileCopyrightText: 2016, 2019 Kai Uwe Broulik <kde@privat.broulik.de>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+#pragma once
+
+#include <QObject>
+#include <QUrl>
+#include <QWeakPointer>
+#include <qqmlregistration.h>
+
+#include "smartlauncherbackend.h"
+
+namespace SmartLauncher
+{
+
+class Item : public QObject
+{
+    Q_OBJECT
+    QML_NAMED_ELEMENT(SmartLauncherItem)
+
+    Q_PROPERTY(QUrl launcherUrl READ launcherUrl WRITE setLauncherUrl NOTIFY launcherUrlChanged)
+
+    Q_PROPERTY(int count READ count NOTIFY countChanged)
+    Q_PROPERTY(bool countVisible READ countVisible NOTIFY countVisibleChanged)
+    Q_PROPERTY(int progress READ progress NOTIFY progressChanged)
+    Q_PROPERTY(bool progressVisible READ progressVisible NOTIFY progressVisibleChanged)
+    Q_PROPERTY(bool urgent READ urgent NOTIFY urgentChanged)
+
+public:
+    explicit Item(QObject *parent = nullptr);
+    ~Item() override = default;
+
+    QUrl launcherUrl() const;
+    void setLauncherUrl(const QUrl &launcherUrl);
+
+    int count() const;
+    bool countVisible() const;
+    int progress() const;
+    bool progressVisible() const;
+    bool urgent() const;
+
+Q_SIGNALS:
+    void launcherUrlChanged(const QUrl &launcherUrl);
+
+    void countChanged(int count);
+    void countVisibleChanged(bool countVisible);
+    void progressChanged(int progress);
+    void progressVisibleChanged(bool progressVisible);
+    void urgentChanged(bool urgent);
+
+private:
+    void init();
+
+    void populate();
+    void clear();
+
+    void setCount(int count);
+    void setCountVisible(bool countVisible);
+    void setProgress(int progress);
+    void setProgressVisible(bool progressVisible);
+    void setUrgent(bool urgent);
+
+    static std::weak_ptr<Backend> s_backend;
+
+    std::shared_ptr<Backend> m_backendPtr;
+
+    QUrl m_launcherUrl;
+    QString m_storageId;
+
+    bool m_inited = false;
+
+    int m_count = 0;
+    bool m_countVisible = false;
+    int m_progress = 0;
+    bool m_progressVisible = false;
+    bool m_urgent = false;
+};
+
+} // namespace SmartLauncher
-- 
2.53.0

